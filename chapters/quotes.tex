\chapterstar{Quotes}

This section should not be included in the final copy;
it contains quotes and bibliographic references that may be useful in the writing of the book.

\vspace{1em}

\section{\longcite{allen_catalogue_1971}}

One of the earliest publications about compiler optimizations. Mentions inlining/IPO.

\begin{quotation}
The term \textit{optimization} is a misnomer in that it is not generally clear that a particular, so called, optimizing transformation even results in an improvement to the program. A more correct term would be "amelioration."
\end{quotation}

\section{\longcite{the_first_computers_2002}}

\begin{quotation}
The chief programmer of Mark I, Richard M. Bloch, kept a notebook in which he wrote out pieces of code
that had been checked out and were known to be correct. One of Bloch's routines computed sines for
positive angles less that 45 degrees to only ten digits. Rather than use the slow sine unit built into the
machine, Grace Hopper simply copied Dick's routine into her own program whenever she knew it would suit
her requirements. This practice ultimately allowed the programmers to dispense with the sine, logarithm, and
exponential units altogether. Both Bloch and Bob Campbell had notebooks full of such pieces of code. Years
later, the programmers realized that they were pioneering the art of subroutines and actually developing the
possibility of building compilers.
\end{quotation}

\begin{quotation}
There were sets of instructions for integers, floating-point numbers, packed decimal numbers, and character
strings; operating in a variety of modes. This philosophy had evolved in an environment dominated by
magnetic core memory, to which access was slow relative to processor operations. Thus it made sense to
specify in great detail what one wanted to do with a piece of data before going off to memory to get it. The
instruction sets also reflected the state of compiler technology. If the processor could perform a lot of
arithmetic on data with only one instruction, then the compiler would have that much less work to do. A rich
instruction set would reduce the "semantic gap" between the English-like commands of a high-level
programming language and the primitive and tedious commands of machine code. Cheap read-only memory
chips meant that the designer could create these rich instruction sets at low cost if the computer was microprogrammed.
\end{quotation}

p. 270
\begin{quotation}
In the following sections, expressions such as "hardware", "software", "machine language", "compiler",
"architecture" and the like are used freely, although they were unknown in 1950. They only arrived a decade
later, but the underlying concepts were quite familiar to us.
\end{quotation}

\begin{quotation}
    We also made some hardware changes. Rutishauser, who was exceptionally creative, devised a way of
letting the Z4 run as a compiler, a mode of operation which Zuse had never intended. For this purpose, the
necessary instructions were interpreted as numbers and stored in the memory. Then, a compiler program
calculated the program and punched it out on a tape. All this required certain hardware changes. Rutishauser
compiled a program with as many as 4000 instructions. Zuse was quite impressed when we showed him this
achievement.
\end{quotation}

\section{\longcite{grace_hopper_and_the_invention_of_the_information_age_2009}}

\begin{quotation}
Though it is sometimes difficult to identify the motivation behind particular i
nventions, it appears that a dearth of talented programmers, a personal frustrat
ion with the monotony of existing programming techniques, and the lack of resour
ces made available by senior management at Remington Rand to support computer cl
ients led Hopper to invent the technologies and techniques, such as the compiler
, that allowed the computers to, in effect, help program themselves. Interesting
ly enough, as her A-0 compiler evolved into the A-1 and the A-2, Hopperâ€™s reason
ing in regard to the invention changed. Compilers became less about relieving pr
ogrammers of the monotony of coding and more about reducing programming costs an
d processing time.
\end{quotation}

\section{\longcite{hopl_keynote}}
\begin{quotation}
    Mark I had built-in programs for sine, cosine, exponential, arctangent, .-... On the
other hand, because they were wired into the machine, they had to be completely general.
Any problem that we solved, we found we did not need complete generality; we always
knew something about what we were doing--that was what the problem was. And the answer was--we started writing subroutines, only we thought they were pieces of coding.
And if I needed a sine subroutine, angle less than zr/4, I'd whistle at Dick and say, "Can I
have your sine subroutine?" and I'd copy it out of his notebook. We soon found that we
needed just a generalized format of these if we were going to copy them, and I found a
generalized subroutine for Mark I. With substitution of certain numbers, it can be copied
into any given program. So as early as 1944 we started putting together things which would
make it easier to write more accurate programs and get them written faster. I think we've
forgotten to some extent how early that started.
\end{quotation}
