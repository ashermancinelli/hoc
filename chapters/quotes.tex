\chapterstar{Quotes}

This section should not be included in the final copy;
it contains quotes and bibliographic references that may be useful in the writing of the book.

\vspace{1em}

\quotesection{allen_catalogue_1971}

One of the earliest publications about compiler optimizations. Mentions inlining/IPO.

\begin{quotation}
The term \textit{optimization} is a misnomer in that it is not generally clear that a particular, so called, optimizing transformation even results in an improvement to the program. A more correct term would be "amelioration."
\end{quotation}

\quotesection{hopl_keynote}
\begin{quotation}
    Mark I had built-in programs for sine, cosine, exponential, arctangent, .-... On the
other hand, because they were wired into the machine, they had to be completely general.
Any problem that we solved, we found we did not need complete generality; we always
knew something about what we were doing--that was what the problem was. And the answer was--we started writing subroutines, only we thought they were pieces of coding.
And if I needed a sine subroutine, angle less than zr/4, I'd whistle at Dick and say, "Can I
have your sine subroutine?" and I'd copy it out of his notebook. We soon found that we
needed just a generalized format of these if we were going to copy them, and I found a
generalized subroutine for Mark I. With substitution of certain numbers, it can be copied
into any given program. So as early as 1944 we started putting together things which would
make it easier to write more accurate programs and get them written faster. I think we've
forgotten to some extent how early that started.
\end{quotation}

\quotesection{the_first_computers_2002}

\begin{quotation}
The chief programmer of Mark I, Richard M. Bloch, kept a notebook in which he wrote out pieces of code
that had been checked out and were known to be correct. One of Bloch's routines computed sines for
positive angles less that 45 degrees to only ten digits. Rather than use the slow sine unit built into the
machine, Grace Hopper simply copied Dick's routine into her own program whenever she knew it would suit
her requirements. This practice ultimately allowed the programmers to dispense with the sine, logarithm, and
exponential units altogether. Both Bloch and Bob Campbell had notebooks full of such pieces of code. Years
later, the programmers realized that they were pioneering the art of subroutines and actually developing the
possibility of building compilers.
\end{quotation}

\begin{quotation}
There were sets of instructions for integers, floating-point numbers, packed decimal numbers, and character
strings; operating in a variety of modes. This philosophy had evolved in an environment dominated by
magnetic core memory, to which access was slow relative to processor operations. Thus it made sense to
specify in great detail what one wanted to do with a piece of data before going off to memory to get it. The
instruction sets also reflected the state of compiler technology. If the processor could perform a lot of
arithmetic on data with only one instruction, then the compiler would have that much less work to do. A rich
instruction set would reduce the "semantic gap" between the English-like commands of a high-level
programming language and the primitive and tedious commands of machine code. Cheap read-only memory
chips meant that the designer could create these rich instruction sets at low cost if the computer was microprogrammed.
\end{quotation}

p. 270
\begin{quotation}
In the following sections, expressions such as "hardware", "software", "machine language", "compiler",
"architecture" and the like are used freely, although they were unknown in 1950. They only arrived a decade
later, but the underlying concepts were quite familiar to us.
\end{quotation}

\begin{quotation}
    We also made some hardware changes. Rutishauser, who was exceptionally creative, devised a way of
letting the Z4 run as a compiler, a mode of operation which Zuse had never intended. For this purpose, the
necessary instructions were interpreted as numbers and stored in the memory. Then, a compiler program
calculated the program and punched it out on a tape. All this required certain hardware changes. Rutishauser
compiled a program with as many as 4000 instructions. Zuse was quite impressed when we showed him this
achievement.
\end{quotation}

\quotesection{grace_hopper_and_the_invention_of_the_information_age_2009}

\begin{quotation}
Though it is sometimes difficult to identify the motivation behind particular i
nventions, it appears that a dearth of talented programmers, a personal frustrat
ion with the monotony of existing programming techniques, and the lack of resour
ces made available by senior management at Remington Rand to support computer cl
ients led Hopper to invent the technologies and techniques, such as the compiler
, that allowed the computers to, in effect, help program themselves. Interesting
ly enough, as her A-0 compiler evolved into the A-1 and the A-2, Hopper’s reason
ing in regard to the invention changed. Compilers became less about relieving pr
ogrammers of the monotony of coding and more about reducing programming costs an
d processing time.
\end{quotation}

\textit{Programming} was considered the action of writing machine code directly;
writing code in a high-level language was not even considered programming.
The motivation for writing Hopper's first compiler was to offload this task
to the computer itself.

\begin{quotation}
First and
foremost, the central motivations for automatic programming
were far more personal in the 1952 paper. With the construction
of a functioning compiler, Hopper hoped, "the programmer
may return to being a mathematician." Though Hopper had
sincerely enjoyed the challenge of coding since first being introduced to computers 8 years earlier, she wrote, "the novelty of
inventing programs wears off and degenerates into the dull labor
of writing and checking programs. The duty now looms as an
imposition on the human brain." By teaching computers to
program themselves, Hopper would be free to explore other
intellectual pursuits 
\end{quotation}

\begin{quotation}
These computing pioneers, according to
Hopper, created machines and methods that removed the arithmetical chore from the mathematician. This chore, however, was
replaced by the new burden of writing code, thus turning mathematicians into programmers. Hopper's paper boldly offers the
next step in the history of computing: shifting the humanmachine interface once again so as to free the mathematician
from this new burden, and making "the compiling routine be
the programmer and perform all those services necessary to the
production of a fi nished program."
\end{quotation}

\begin{quotation}
He [the mathematician] is supplied with a catalogue of subroutines. No
longer does he need to have available formulas or tables of elementary
functions. He does not even need to know the particular instruction
code used by the computer. He needs only to be able to use the catalogue to supply information to the computer about his problem.20
The “catalogue of subroutines” was a menu that listed all the
input information needed by the compiler to look up subroutines in the library, assemble them in the proper order, manage
address assignments, allocate memory, transcribe code, and create
a fi nal program in the computer’s specifi c machine code.21 A
subroutine entry in the catalogue consisted of a subroutine
“call-number” and the order in which arguments, controls, and
results were to be stated. The call-number identifi ed the type of
subroutine (t for trigonometric, x for exponential, etc.), specified
transfer of control (entrance and exit points in each subroutine),
and set operating and memory requirements. In fact, language
such as “call-number” and “library” compelled Hopper to name
her program generator a “compiler,” for it compiled subroutines
into a program in much the same way that historians compile
books into an organized bibliography.22
\end{quotation}

\begin{quotation}
A program generated by a compiler could not only be
run as a stand alone program whenever desired; it also “may itself
be placed in the library as a more advanced subroutine.” This
suggested that subroutine libraries could increase in size and
complexity at an exponential rate, thus enabling mathematicians
to solve problems once deemed impossible or impractical.23
\end{quotation}

\begin{quotation}
Hopper ends the paper by establishing a short-term roadmap
for the future development of compilers. She describes a “typeB” compiler, which, by means of multiple passes, could supplement computer information provided by the programmer with
self-generated information. Such a compiler, she imagines, would
be able to automate the process of solving complex differential
equations. To obtain a program to compute $f(x)$ and its first $n$
derivatives, only $f(x)$ and the value of n would have to be given.
The formulas for the derivatives of $f(x)$ would be derived by
repeated application of the type-B compiler.24
Hopper also admits that the current version of her compiler
did not have the ability to produce efficient code. For example,
if both sine and cosine were called for in a routine, a smart
programmer would fi gure out how to have the program compute them simultaneously. Hopper’s compiler would embed both
a sine subroutine and a cosine subroutine in sequence, thus
wasting valuable memory and processing time. Hopper states
boldly that the skills of an experienced programmer could eventually be distilled and made available to the compiler. She concludes as follows:
\end{quotation}

\begin{quotation}
Although the test results appear to be a smashing endorsement
of the A-0 compiler, Ridgway dedicates a substantial amount of
his paper to the ineffi ciency of run-programs. (A “run-program”
was the fi nal product of the compiler process. Today, such a
program is called object or machine code.) During the 5 months
since Hopper had introduced compilers, critics had pointed out
that run-programs generated by compilers were less effi cient than
those created by seasoned programmers... 

Furthermore, an hour of computer time was far more costly in 1952 than an hour of programmer time. 
\end{quotation}

\begin{quotation}
Ridgway acknowledged that using compilers took up more
computer time, both as a result of compiling a program and as
a consequence of ineffi cient code. But “in this case,” he argued,
“the compiler used was the ‘antique,’ or A-0, the fi rst to be
constructed and the most ineffi cient.” Ridgway was confi dent
that Hopper and her team at the Computation Analysis Laboratory would construct new compilers that “squeezed” coding
into “neat, effi cient, and compact little packages of potential
computation.”29
\end{quotation}

\begin{quotation}
A closer look at the manual for the A-2 compiler (produced
by the Computation Analysis Laboratory during the summer of
1953) suggests that, despite the signifi cant improvements over
the A-0 compiler, automatic programming had its limitations.
Hopper’s vision of intuitive, user-friendly, hardware-independent
pseudo-codes generating effi cient running programs was far
from realization. The A-2 provided a three-address “pseudocode” specifi cally designed for the UNIVAC I 12-character standards. The manual defi ned “pseudo-code” as “computer words
other than the machine (C-10) code, designed with regard to
facilitating communications between programmer and computer.”32 Today we refer to it as source code. Since pseudo-code
could not be directly executed by the UNIVAC I, the A-2 compiler included a translator routine which converted the pseudocode into machine code. (See table 8.3.)
The manual states that the pseudo-code is “a new language
which is easier to learn and much shorter and quicker to write.”33
\end{quotation}

\begin{quotation}
 The most groundbreaking change was the A-2's ability to debug
pseudo-code and fl ag errors automatically. The compiler generated twelve-character error codes that captured the nature of the
error, a miraculous innovation for any programmer who had
experienced the pain and monotony of debugging computer
code. (See table 8.4.)
\end{quotation}

Pseudocode was actually the innovation of compilers as we know them today,
which didn't wasn't part of Hopper's compilers until the A-2.
Prior to that, it was really a way to link/load programs from a library of subroutines.

\begin{quotation}
First, the designer of the compiler now was a linguist. That is,
the compiler programmer had the ability to design the syntax of
the pseudo-code.
\end{quotation}
\begin{quotation}
Not only would it be far easier to learn
than machine code; its intuitive logic would help users debug
their work. “I felt,” Hopper recalled, “that sooner or later . . .
our attitude should be not that people should have to learn how
to code for the computer but rather the computer should learn
how to respond to people because I fi gured we weren’t going to
teach the whole population of the United States how to write
computer code, and that therefore there had to be an interface
built that would accept things which were people-oriented and
then use the computer to translate to machine code.”38

She mentioned that compilers
could be designed to program the machine code of any computer. “A problem stated in a basic pseudo-code can thus be
prepared for running on one or more computers if the corresponding compiler and subroutine library is available,” she wrote.
Just as the compiler freed the user from knowing how to program
in machine language, pseudo-code was now liberated from a
specifi c type of hardware. A payroll pseudo-code could run on
a UNIVAC or an IBM computer, so long as the appropriate
compiler was running on both. Hopper stated that as of May
1952 such a benefi t was theoretical, insofar as her laboratory had
tried it only once, with inconclusive results.39

Though interpreters were simpler to use than programming in
machine code, Hopper believed the approach was a step in the
wrong direction. Compiling the A-2 pseudo-code was time consuming in the short term, but the resultant run-program eliminated these six interpretive steps and thus could run more
effi ciently. In her fi nal comparison of interpreters and compilers,
Hopper wrote: “In both cases, the advantage over manual programming is very great, once the basic subroutines have been
tested and proved. The saving of time for a compiler is usually
greater.”40
\end{quotation}

\begin{quotation}
Moreover, Hopper’s network of invention attracted the enthusiastic participation of many women in the programming fi eld.
Nora Moser (of the Army Map Service), Betty Holberton (at the
David Taylor Basin), Margaret Harper (of the Remington Rand/
Naval Aviation Supply Office), and Mildred Koss (of Remington
Rand) viewed the compiler as more than just a new programming concept. Indeed, they saw it as the centerpiece of an innovative automated system of programming that they had a hand
in creating.
\end{quotation}
\begin{quotation}
The fact that Hopper wholeheartedly welcomed nonUNIVAC personnel to learn about the A-2 compiler sheds some
light on her beliefs concerning intellectual property. Hopper did
not view software as a commodity to be patented and sold.
Rather, she took her cue from the mathematics community. Like
most other academics, mathematicians shared information universally, in order to advance knowledge.
\end{quotation}
\begin{quotation}
Refl ecting on the negative reactions of some of her fellow
programmers, Hopper expressed the belief that arguments focusing on “effi ciency” and “creativity” covered far baser motivations:
“Well, you see, someone learns a skill and works hard to learn
that skill, and then if you come along and say, ‘you don’t need
that, here’s something else that’s better,’ they are going to be quite
indignant.” In fact, Hopper felt that by the mid 1950s many
programmers viewed themselves as “high priests,” for only they
could communicate with such sophisticated machines.

Hopper was not the only one who came to this conclusion.
John Backus, developer of Speedcode and later of FORTRAN,
was conscious of the programming community’s reaction to his
contributions: “Just as freewheeling westerners developed a chauvinistic pride in their frontiersmanship and a corresponding conservatism, so many programmers of the freewheeling 1950s began
to regard themselves as members of a priesthood guarding skills
and mysteries far too complex for ordinary mortals.”54 But the
more the likes of Backus and Hopper preached the benefi ts of
automatic programming, the more concerned the programming
priesthood became about the spreading technology.
\end{quotation}

\quotesection{hiltzik1999dealers}

Vendor lock-in was tremendously powerful at the time, if only for hardware reasons (expensive, difficult to move/transition).
The instruction set was only part of the problem.
Compilers gave a way to break out of vendor lock-in at the ISA level by giving programmers
a higher-level target, but still depended on orgs being able and willing to switch hardware.
\begin{quotation}
Once IBM sold the system to United Airlines, it could rest assured that the frightful effort of rewriting software,
retraining, staff, and moving tons of iron and steel cabinets around would make unit very long and hard before 
replacing its IBM system by one made by, say, Honeywell.
\end{quotation}
