\chapterstar{Quotes}

This section should not be included in the final copy;
it contains quotes and bibliographic references that may be useful in the writing of the book.

\vspace{1em}

\quotesection{allen_catalogue_1971}

One of the earliest publications about compiler optimizations. Mentions inlining/IPO.

\begin{quotation}
The term \textit{optimization} is a misnomer in that it is not generally clear that a particular, so called, optimizing transformation even results in an improvement to the program. A more correct term would be "amelioration."
\end{quotation}

\quotesection{the_first_computers_2002}

\begin{quotation}
The chief programmer of Mark I, Richard M. Bloch, kept a notebook in which he wrote out pieces of code
that had been checked out and were known to be correct. One of Bloch's routines computed sines for
positive angles less that 45 degrees to only ten digits. Rather than use the slow sine unit built into the
machine, Grace Hopper simply copied Dick's routine into her own program whenever she knew it would suit
her requirements. This practice ultimately allowed the programmers to dispense with the sine, logarithm, and
exponential units altogether. Both Bloch and Bob Campbell had notebooks full of such pieces of code. Years
later, the programmers realized that they were pioneering the art of subroutines and actually developing the
possibility of building compilers.
\end{quotation}

\begin{quotation}
There were sets of instructions for integers, floating-point numbers, packed decimal numbers, and character
strings; operating in a variety of modes. This philosophy had evolved in an environment dominated by
magnetic core memory, to which access was slow relative to processor operations. Thus it made sense to
specify in great detail what one wanted to do with a piece of data before going off to memory to get it. The
instruction sets also reflected the state of compiler technology. If the processor could perform a lot of
arithmetic on data with only one instruction, then the compiler would have that much less work to do. A rich
instruction set would reduce the "semantic gap" between the English-like commands of a high-level
programming language and the primitive and tedious commands of machine code. Cheap read-only memory
chips meant that the designer could create these rich instruction sets at low cost if the computer was microprogrammed.
\end{quotation}

p. 270
\begin{quotation}
In the following sections, expressions such as "hardware", "software", "machine language", "compiler",
"architecture" and the like are used freely, although they were unknown in 1950. They only arrived a decade
later, but the underlying concepts were quite familiar to us.
\end{quotation}

\begin{quotation}
    We also made some hardware changes. Rutishauser, who was exceptionally creative, devised a way of
letting the Z4 run as a compiler, a mode of operation which Zuse had never intended. For this purpose, the
necessary instructions were interpreted as numbers and stored in the memory. Then, a compiler program
calculated the program and punched it out on a tape. All this required certain hardware changes. Rutishauser
compiled a program with as many as 4000 instructions. Zuse was quite impressed when we showed him this
achievement.
\end{quotation}

\quotesection{grace_hopper_and_the_invention_of_the_information_age_2009}

\begin{quotation}
Though it is sometimes difficult to identify the motivation behind particular i
nventions, it appears that a dearth of talented programmers, a personal frustrat
ion with the monotony of existing programming techniques, and the lack of resour
ces made available by senior management at Remington Rand to support computer cl
ients led Hopper to invent the technologies and techniques, such as the compiler
, that allowed the computers to, in effect, help program themselves. Interesting
ly enough, as her A-0 compiler evolved into the A-1 and the A-2, Hopper’s reason
ing in regard to the invention changed. Compilers became less about relieving pr
ogrammers of the monotony of coding and more about reducing programming costs an
d processing time.
\end{quotation}

\textit{Programming} was considered the action of writing machine code directly;
writing code in a high-level language was not even considered programming.
The motivation for writing Hopper's first compiler was to offload this task
to the computer itself.

\begin{quotation}
First and
foremost, the central motivations for automatic programming
were far more personal in the 1952 paper. With the construction
of a functioning compiler, Hopper hoped, "the programmer
may return to being a mathematician." Though Hopper had
sincerely enjoyed the challenge of coding since first being introduced to computers 8 years earlier, she wrote, "the novelty of
inventing programs wears off and degenerates into the dull labor
of writing and checking programs. The duty now looms as an
imposition on the human brain." By teaching computers to
program themselves, Hopper would be free to explore other
intellectual pursuits 
\end{quotation}

\begin{quotation}
These computing pioneers, according to
Hopper, created machines and methods that removed the arithmetical chore from the mathematician. This chore, however, was
replaced by the new burden of writing code, thus turning mathematicians into programmers. Hopper's paper boldly offers the
next step in the history of computing: shifting the humanmachine interface once again so as to free the mathematician
from this new burden, and making "the compiling routine be
the programmer and perform all those services necessary to the
production of a fi nished program."
\end{quotation}

\begin{quotation}
He [the mathematician] is supplied with a catalogue of subroutines. No
longer does he need to have available formulas or tables of elementary
functions. He does not even need to know the particular instruction
code used by the computer. He needs only to be able to use the catalogue to supply information to the computer about his problem.20
The “catalogue of subroutines” was a menu that listed all the
input information needed by the compiler to look up subroutines in the library, assemble them in the proper order, manage
address assignments, allocate memory, transcribe code, and create
a fi nal program in the computer’s specifi c machine code.21 A
subroutine entry in the catalogue consisted of a subroutine
“call-number” and the order in which arguments, controls, and
results were to be stated. The call-number identifi ed the type of
subroutine (t for trigonometric, x for exponential, etc.), specified
transfer of control (entrance and exit points in each subroutine),
and set operating and memory requirements. In fact, language
such as “call-number” and “library” compelled Hopper to name
her program generator a “compiler,” for it compiled subroutines
into a program in much the same way that historians compile
books into an organized bibliography.22
\end{quotation}

\begin{quotation}
A program generated by a compiler could not only be
run as a stand alone program whenever desired; it also “may itself
be placed in the library as a more advanced subroutine.” This
suggested that subroutine libraries could increase in size and
complexity at an exponential rate, thus enabling mathematicians
to solve problems once deemed impossible or impractical.23
\end{quotation}

\begin{quotation}
Hopper ends the paper by establishing a short-term roadmap
for the future development of compilers. She describes a “typeB” compiler, which, by means of multiple passes, could supplement computer information provided by the programmer with
self-generated information. Such a compiler, she imagines, would
be able to automate the process of solving complex differential
equations. To obtain a program to compute $f(x)$ and its first $n$
derivatives, only $f(x)$ and the value of n would have to be given.
The formulas for the derivatives of $f(x)$ would be derived by
repeated application of the type-B compiler.24
Hopper also admits that the current version of her compiler
did not have the ability to produce efficient code. For example,
if both sine and cosine were called for in a routine, a smart
programmer would fi gure out how to have the program compute them simultaneously. Hopper’s compiler would embed both
a sine subroutine and a cosine subroutine in sequence, thus
wasting valuable memory and processing time. Hopper states
boldly that the skills of an experienced programmer could eventually be distilled and made available to the compiler. She concludes as follows:
\end{quotation}

\begin{quotation}
Although the test results appear to be a smashing endorsement
of the A-0 compiler, Ridgway dedicates a substantial amount of
his paper to the ineffi ciency of run-programs. (A “run-program”
was the fi nal product of the compiler process. Today, such a
program is called object or machine code.) During the 5 months
since Hopper had introduced compilers, critics had pointed out
that run-programs generated by compilers were less effi cient than
those created by seasoned programmers... 

Furthermore, an hour of computer time was far more costly in 1952 than an hour of programmer time. 
\end{quotation}

\begin{quotation}
Ridgway acknowledged that using compilers took up more
computer time, both as a result of compiling a program and as
a consequence of ineffi cient code. But “in this case,” he argued,
“the compiler used was the ‘antique,’ or A-0, the fi rst to be
constructed and the most ineffi cient.” Ridgway was confi dent
that Hopper and her team at the Computation Analysis Laboratory would construct new compilers that “squeezed” coding
into “neat, effi cient, and compact little packages of potential
computation.”29
\end{quotation}

\quotesection{hopl_keynote}
\begin{quotation}
    Mark I had built-in programs for sine, cosine, exponential, arctangent, .-... On the
other hand, because they were wired into the machine, they had to be completely general.
Any problem that we solved, we found we did not need complete generality; we always
knew something about what we were doing--that was what the problem was. And the answer was--we started writing subroutines, only we thought they were pieces of coding.
And if I needed a sine subroutine, angle less than zr/4, I'd whistle at Dick and say, "Can I
have your sine subroutine?" and I'd copy it out of his notebook. We soon found that we
needed just a generalized format of these if we were going to copy them, and I found a
generalized subroutine for Mark I. With substitution of certain numbers, it can be copied
into any given program. So as early as 1944 we started putting together things which would
make it easier to write more accurate programs and get them written faster. I think we've
forgotten to some extent how early that started.
\end{quotation}
