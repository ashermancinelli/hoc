
A surprising number of the foundations for programming language
theory were laid before
many familiar programming concepts were developed.
Higher-order logic, combinatory logic, and \lambdacalc{} were
all being developed prior to their uses in programming languages
with the aim of providing a firm foundation for \textit{mathematics},
and would only cross-polinate with programming languages later on.

Let me digress for a moment before we begin.
Students of computer science often feel a sense of bewilderment
when they are first introduced to many foundational concepts
in a way that is unique to the field
\footnote{You will have to take my word on this. I provide no evidence,
	but I believe readers will come to agree.}.
I believe the reason for this is that the field is directly built
upon information theory and higher-order logic, fields which were
only recently developed in the history of mathematics, and contain
some unsettling and bewildering concepts.

In the early 20\textsuperscript{th}, Russell's paradox
\footnote{Essentially, set-theory constructions of mathematics lead to contradictions.}
was recently developed
and GÃ¶del's incompleteness theorems
\footnote{Essentially, every formal logical system contains true statements that it is unable to prove.}
were not.
For those unfamiliar, they call into question the validity of the foundations
of mathematics and point out the limits of provability.
These led to several efforts to establish a firm foundation for the entire
field of mathematics, some of which were based on sets and other functions
and the two that we concern ourselves with here are \textit{combinatory logic}
(abbreviated \textit{\acrshort{cl}} from here) and \lamc (occasionally abbreviated \lam{}),
which were attempts to use functions.
They are closely related and share many concepts.
These efforts directly led to functional programming and type theory,
and underpin many other concepts in programming languages and compilers.

I am no expert in this field and it does not entirely concern the history
of compilers, so we will digress only insofar as it informs our topics of focus.
