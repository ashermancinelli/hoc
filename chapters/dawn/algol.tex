\section{ALGOL}

\subsection{The IAL and the ALGOrithmic Language}

Before Hopper, Mayes and Phillips pulled together their committees for a common
business language, design-by-committee was already in the academic milieu,
especially in Europe.
While not commercially successful, ALGOL introduced a number of important concepts
like block scopes and the declaration of the types of variables, and it would
go on to be the standard language for describing algorithms in academia.
Originally called IAL (International Algebraic Language), it came to be called
ALGOL, or ALGOrithmic Language, and was designed by an international committee
with representatives from different organizations with the goal of a truly
machine-independent language.

After deliberation in numerous committees, representatives from the German
Association for Applied Mathematics and Machinery (GAMM) and the ACM met in
Zurich, Switzerland in the summer of 1958. They had both produced similar
reports and wanted to meet and agree on a unified language.
John Backus, Charles Katz, Alan Perlis and Joseph Wegstein from the ACM attended this meeting.
\todo{who were these people? Add some narrative. Maybe of Naur, then tie in with Backus.}
They arrived at the following objectives
\cite{perlis_samelson_1958_preliminary_report_ial}:

\begin{enumerate}
	\item The new language should be as close as possible to standard mathematical
	      notation and be readable with little further explanation.
	\item It should be possible to use it for the description of computing processes in publications.
	\item The new language should be mechanically translatable into machine programs.
\end{enumerate}

Shortly thereafter, a large number of dialects and partial implementations sprung up around Europe
and the US such as BALGOL from Burroughs Corporation in Detroit, Michigan for the Burroughs 220.
Manufacturers such as Burroughs found the standard to be insufficient for their users:
"BAC-220 provides additions for the ALGOL reference language which are essential to
the operation of data-processing systems: input-output
facilities, conventions for inclusion of segments of machine-language coding,
and diagnostic features" \cite{burroughs1963bac220}.
This was intentional; the specifications of ALGOL (both the 1958 and the 1960 versions)
was solely for the purposes of
describing computation; no I/O or system libraries were specified.
Other dialects included CLIP, JOVIAL, MAD, and NELIAC.
The first issue of the \textit{ALGOL Bulletin} was issued in March of 1959 out of Copenhagen
with Peter Naur as the editor.

Jean Sammet describes the impact of ALGOL 58
\cite{sammet_programming_languages_history_and_fundamentals_1969}:
\begin{quotation}
	Among the more intriguing technical features of ALGOL 58 were its essential
	simplicity; the introduction of the concept of three levels of language, namely
	a reference language, a publication language, and hardware representations; the
	\textbfit{begin\dots end} delimiters for creating a single (compound) statement from simpler
	ones; the flexibility of the procedure declaration and the \textbfit{do} statement for
	copying procedures with data name replacement allowed; and the provision for
	empty parameter positions in procedure declarations. While ALGOL 58 is not an
	exact subset of ALGOL 60, the only items of significance which are in the
	former but not the latter are the \textbfit{do} which was removed as a concept (although
	the word was used for something else) and the empty parameter positions.
	Because of this major carry-over, specific technical description of ALGOL 58 is
	not necessary.
\end{quotation}

\subsection{ALGOL 60}

\todo{backstory of Peter Naur}

The International Conference on Information Processing was held in Paris
in June, 1959, where there were several key developments in ALGOL.
Firstly, John Backus presented the now-famous paper on Backus-Naur Form
for formal specification of programming languages\cite{backus_ial_1959}.
Although other accounts describe this paper as having garnered significant
attention in the IAL proceedings, Backus would recount that his paper
"was received with a silence that made it seem that precise syntax
description was an idea whose time had not yet come.
As far as I know that paper had only one reader, Peter Naur"
\cite{Backus_1980_Programming_in_America_in_1950s}.
Backus was involved in two programming languages at the time, \FTN{} and IAL,
having already moved on from Speedcoding.
Backus had been made aware of the logician Emil Post and her work on computability
in a course given by Martin Davis, in particular, Post's notion of a "production."
It was this concept that inspired Backus to write the 1959 paper, and Naur
would go on to extend it. This is part of Backus's specification of arithmetic expressions
in the paper before Naur's changes\cite{backus_ial_1959}:

\[
	\langle \textit{factor} \rangle :\equiv
	\langle \textit{number} \rangle \;\overline{\text{or}}\;
	\langle \textit{function} \rangle \;\overline{\text{or}}\;
	\langle \textit{variable} \rangle \;\overline{\text{or}}\;
	\dots
\]

Naur would make the notation more readable by replacing $\overbar{or}$ with $|$
and $:\equiv$ with $::=$ and by fully spelling out names that backus had abbreviated.
Naur's edits and extensions would bring interest from more readers than Backus's original paper had.
This form would come to be known as Backus-Naur Form, or BNF.
Naur would submit this in a paper to the subsequent ALGOL meeting in 1960,
titled \citetitle{naur_backus_algol_1960}\cite{naur_backus_algol_1960}.
Various commitees had established some shortfalls of the original design of the AIL,
and the 1960 meeting set out to address them with the help of Backus and Naur's
specification.
This report "represents the union of the Committee's concepts and the
intersection of its agreements."
The IAL had been renamed ALGOL 58 and then finally ALGOL 60 in Naur's report.

The final report specified expressions to have the following syntax:

\[
	\langle \textit{expression} \rangle ::=
	\langle \textit{arithmetic expression} \rangle
	| \langle \textit{Boolean expression} \rangle
	| \langle \textit{designational expression} \rangle
\]

\subsection{Adoption of ALGOL}

The \textit{ACM Communications} started publishing an \textit{Algorithms} section;
ALGOL 58 was initially used, but ALGOL 60 was adopted once the updated report
was in wide circulation.
\FTN was not considered acceptable for publication until 1966, and even then
it did not see widespread use in the journal.
Because ALGOL had been designed from scratch by committee, there were
no reference compilers for people to use; the only way to verify the correctness
of an algorithm described in ALGOL was to rewrite it in another language
and run test against test cases.

In early 1960, the \textit{ACM ALGOL Maintenance Group} formed: an informal working
group for the purpose of discussing the implementation of an ALGOL compiler.
They discussed ambiguities in the specification and potential changes to the ALGOL 60 report.
They mostly corresponded by mail and reports of their discussions were synthesized in
the \textit{ALGOL Bulletin}\cite{sammet_programming_languages_history_and_fundamentals_1969}.
The 14 issue of the bulletin in 1962 contained a questionnaire from Peter Naur
about some ambiguities in the 1960 report, and the philosophy of some proposed changes and
enhancements to the language.
\footnote{The reader may find it interesting that in this edition of the bulletin,
	Jean Sammet submitted a paper on \textit{A Method of Combining ALGOL and COBOL};
	\todo{follow up on this?}}
This questionnaire was used as a guide for another committee meeting in Rome in April of 1962
the primary result of this meeting is detailed in Naur's
\citetitle{naur_revised_report_algol_1962}.

\subsection{Peculiarities of ALGOL}

The reader may find it interesting that ALGOL had a number of peculiar features.
Namely, the distinction between \textit{call by name} and \textit{call by value}.
Naur's 1962 revised report explains it best, I think\cite[Section 4.7.3]{naur_revised_report_algol_1962}:

\begin{quotation}
	\noindent
	\textbf{4.7.3.1 Value assignment (call by value)}

	of the corresponding actual parameters\dots the effect is as though an
	additional block embracing the procedure body were created in which these
	assignments were made to variables local to this fictitious block\dots

	\noindent
	\textbf{4.7.3.2 Name replacement (call by name)}

	Any formal parameter not quoted in the value list is replaced, throughout the
	procedure body, bu the corresponding actual parameter, after enclosing this
	latter in parentheses wherever syntactically possible.
\end{quotation}

While neither Naur's revised report nor Edgar Dijkstra's
\citetitle{dijkstra_primer_of_algol_programming_1962}
point out the implications of this distinction, it is important to note
the subtle implications.
Call-by-name is not common in modern programming languages, and readers
may find it more similar to macro expansion
(though it is not, in fact, simply textual replacement).
The following example illustrates the difference:

\lstinputlisting[language=python,frame=single]{chapters/dawn/callbyname1.py}

Most implementations of call-by-name use zero-argument thunks to delay
the evaluation of arguments until they are used in the body.
The arguments to function calls become zero-argument closure functions
returning the value of the argument expression and capable of being
\textit{l-values}, or values in the left-hand side of an assignment expression.
Then, each instance of the argument in the callee's body is replaced
with an invocation of this function such that it is evaluated anew
each time it appears.
The prior Python example may be rewritten to emulate call-by-name as follows:

\lstinputlisting[language=python,frame=single]{chapters/dawn/callbyname2.py}

Call-by-value semantics demand that the argument to \texttt{double} be evaluated
before entering the function, so \texttt{get\_5} is called once and
\textit{the result} is passed to \texttt{double}.
With call-by-name semantics, \texttt{get\_5} is passed the expression itself,
which is the substituted into the body of the callee \textit{before}
being evaluated.

Donald Knuth proposed the \textit{man or boy} test in the \textit{ALGOL Bulletin}
to distinguish between
conformant ALGOL compilers capable of handling recursion and non-local references
using call-by-name semantics\cite{Knuth1964ManOrBoy}.

\begin{quotation}
	There are quite a few ALGOL60 translators in existence which have been designed
	to handle recursion and non-local references properly, and I thought perhaps a
	little test-program may be of value. Hence I have written the following simple
	routine, which may separate the man-compilers from the boy-compilers.

	This uses nothing known to be tricky or ambiguous. My question is: What should
	the answer be? Unfortunately, I don't have access to a "man-compiler" myself,
	asn do I was forced to try hand calculations. My conjecture (probably wrong) is
	that the answer will be

	\[
		73 - 119 - 177 + 102 = -121 .
	\]

	I'd be very glad to know the right answer.
\end{quotation}

The program is as follows:

\lstinputlisting[language=algol,frame=single]{chapters/dawn/knuth-man-boy-test.a68}

There are some useful applications of call-by-name semantics as well;
it is not \textit{solely} an avenue for confusion.
Jensen's Device, named in honor of Mr. J. Jensen of Regnecentralen, Copenhagen,
is a well-known application of call-by-name semantics.
This allows the user of a function to describe an expression to be evaluated
in a loop body inside the function, permitting a very general summation function.
There is not an especially elegant way to do this in a call-by-value language,
but as Dijkstra points out\cite{dijkstra_defense_of_algol_60_1961},
it can be implemented with this ALGOL program:

\lstinputlisting[language=algol,frame=single]{chapters/dawn/jensens-device.a68}

To simply sum the values of the array \texttt{V} from 1 to 100, one would call:
\texttt{Sum(i, 1, 100, V[i])}.
The real power of this device is its generality;
if a user were to need to compute $\sum_{i=1}^{100} V_{i}\times i$,
they could call \texttt{Sum(i, 1, 100, V[i]*i)}.
The first and final arguments to this function are not evaluated
until they are used in the body of the loop in \texttt{Sum}.
Others have also pointed out numerous easy-to-make mistakes
that arise because of this feature.
For example, a naive implementation of a swap function may easily
cause unintended side effects:

\lstinputlisting[language=algol,frame=single]{chapters/dawn/swap-error.a68}

While calling \texttt{Swap(i, j)} may work correctly, calling
\texttt{Swap(i+1, j+1)} or \texttt{Swap(A[i], A[j])} would not.

Among the now-unusual argument evaluation semantics, ALGOL also lacked any I/O
facilities as we have already discussed.  The language also made string
variables available, but provided no means of manipulating them.  ALGOL
permitted \textit{own variables}, which are akin to static variables in C or
SAVE variables in \FTN{}; they retain their values between entrances to the
block.  Dijkstra also points out nowhere is the evaluation order of
subexpressions specified\cite{dijkstra_defense_of_algol_60_1961}.

While the declared intent of defining a language detached from any particular
manufacturer or machine was laudable (and profitable in the case of portable
languages to follow), ALGOL was so far removed from the machine to be useless without
supplementary libraries (for I/O, string processing, etc).

\subsection{ALGOL 68 (and X, Y, W, \dots)}

For years after the 1962 Rome meeting, there were discussions amongst the ALGOL
community about potential changes and improvements to the language.
The 1960 and 1962 meetings restricted themselves to clarifying ambiguities
and rectifying true errors in the prior reports, but not extensions or
significant changes.
In the March of 1964 as follow up to Rome meeting, they finally agreed to
start on ALGOL X and ALGOL Y, drafts of the language that would consider
significant changes and additions to the language.
ALGOL X would be intended to solve the issues of ALGOL 60 in the short-term,
compared to the "radically reconstructed future ALGOL Y"
\cite{cleaning_up_algol60_duncan_wijngaarden_1964}.
To summarize the following section: three draft reports were proposed,
Adriaan Van Wijngaarden was asked to revise his draft report until the other
two authors were satisfied,
the draft report that all three were satisfied with became canonized as ALGOL 68,
many people withdrew from the language community (formally or informally)
in reaction to the new language,
and the language was never widely adopted.

\input{chapters/dawn/algol-68-timeline.tex}

In 1965, the first three drafts for ALGOL X were proposed by
Niklaus Wirth (who benefitted from numerous comments from Tony Hoare),
Gerhard Seegmüller, and Adriaan van Wijngaarden.
Seegmüller's proposal was not too different from Wirth and Hoare's, which
was called ALGOL W, but
Wijngaarden's proposal was dramatically different.
Wijngaarden described his ALGOL X language in an entirely new
formal grammar which came to be known as a \textit{W-Grammar} (after his own namesake).

The impact of Wijngaarden's proposal on the development of ALGOL cannot be overstated.
In the spring of 1968, Adriaan van Wijngaarden released a draft report for ALGOL X
(which was, mind you, supposed to be the \textit{incremental} improvement to ALGOL 60)
based on Wirth and Hoare's ALGOL W but using his own W-Grammar.
% The discussions and meetings over ALGOL X overran such that the subsequent
% meeting on ALGOL Y was overtaken by discussion of ALGOL X.
In this time period, Peter Naur and Brian Randall of IBM even suggested that the incremental
ALGOL X be dropped entirely in favor of the more ambitious ALGOL Y.
At nearly every step, the committee ran significantly past their schedules:
"Throughout the whole project, the WG in general, and Van Wijngaarden in particular, consistently
underestimated the time it would take by substantial factors. Recall that ALGOL 60 was put together
in six days"\cite{a_history_of_algol_68_1993}.

Wijngaarden's ALGOL W proposal was distinct for at least three reasons:

\begin{enumerate}
	\item A two-level \textit{W Grammar}.
	\item "The combination of a minimal number of language concepts in an orthogonal way"
	      \cite{a_history_of_algol_68_1993}.
	\item Expression orientation; everything is an expression and has a value.
\end{enumerate}

% The first programming language designed by international committee receive
% significant interest and is still used in academia today, however it never
% gained significant traction.
% Outside of small snippets in academic papers, it was only ever in use by
% the Burroughs Corporation\cite{burroughs1963bac220},
% and their implementation required significant library
% development to provide their programers with an environment capable of doing
% much of anything useful.
The computer and aerospace historian Paul Ceruzzi describes the result of
the ALGOL 68 report as follows:

\begin{quotation}
	Whereas ALGOL-60 was based on a formal structure
	and was very lean, ALGOL-68 was burdened by an attempt to do too
	much, with the effects that some features interfered with the clean
	implementation of others. It was hard to understand. In an attempt to
	satisfy a broad range of users worldwide, the committee produced
	something that satisfied few.
\end{quotation}

Charles Lindsey, British computer scientist and editor of
\citetitlecite{revised_report_on_the_algorithmic_language_algol_68_1976}
(and numerous other texts on ALGOL 68) describes popular sentiment about the
report\cite{a_history_of_algol_68_1993}:
\begin{quotation}
	The world seems to have a rather negative perception of ALGOL 68. The language has been said to
	be "too big," to be defined by an "unreadable Report" produced by a committee which "broke up in
	disarray," to have no implementations, and to have no users.
\end{quotation}

This was not his opinion, however\cite{a_history_of_algol_68_1993}:

\begin{quotation}
	I should point out that my own involvement with the project came after the basic design of the
	language, and of its original Report, were complete\dots
	It is only now, in the course of studying the minutes and other
	documents from that time, that I have come to see what the real fuss was about, and I hope that all
	this has enabled me to take a dispassionate view of the events. The reader of this paper will certainly
	see discord, but I believe he will see also how good design can win through in the end.
\end{quotation}

Lindsey was appointed Lecturer in Computer Science at Manchester University
in 1967. Aside from his standardization efforts, he wrote a research implementations of
ALGOL 68 for the MU5, one of the Manchester computers, and he maintained an
implementation of a subset of ALGOL 68, \textit{ALGOL 68S}.
It is difficult to take Lindsey's opinions about ALGOL 68 entirely at face
value because so much of his career was dedicated to the language.
If we look at those involved with the design of ALGOL 68 who
had programming language design and compiler experience elsewhere,
we find his depiction above to be more accurate than not.

Another meeting in May 1967 in Zandvoort, Netherlands was intended to develop a direction for ALGOL Y,
however nearly all the discussion was about ALGOL X.
From the outset, the only language aspect the designers knew they wanted from ALGOL Y
was the ability for an ALGOL Y program to modify itself.
Lindsey remarks:

\begin{quotation}
	They even spent an afternoon on ALGOL Y, from which it emerged that no one had
	very concrete ideas of what it was about, and that the only role model was
	LISP, on account of the fact that that language could construct its own
	programs and then \textit{eval} them.
\end{quotation}

The largest single outpouring of criticism of ALGOL 68 came from
\citetitlecite{mr93_draft_report_on_algol_68_1968}, also known as [MR93].
Several members of the committee (including Peter Naur) resigned
after this report's circulation.
It was first circulated to the \textit{ALGOL Bulletin} in February 1968,
and "was the cause of much shock, horror, and dissent, even
(perhaps especially) among the membership of WG 2.1"\cite{a_history_of_algol_68_1993}.
Numerous papers were written in response to MR93, including Peter Naur's \textit{scathing}
critique \citetitle{successes_and_failures_of_the_algol_effort_naur_1968}.
His report was especially critical of the International Federation for Information Processing
(IFIP), which had formed a working-group (WG 2.1) responsible for specifying the language.

Also in response to MR93, Lindsey joined the language effort and
distributed his \citetitlecite{algol68_with_fewer_tears_1968}
in which he attempted to synthesize the nicer language hidden within the earlier reports
\footnote{For those unaware, this title is an homage to the English textbook \textit{French without Tears}.}.
He clarified a number of terms which appear to be specific to ALGOL, and
have well-understood meanings under different names in other languages.
For example, what ALGOL calls a \textit{name} is more commonly known as a reference or pointer;
numerous differences in nomenclature contributed to the difficulty of reading
the original reports.

Van Wijngaarden had circulated another
report\cite{penultimate_draft_report_on_algol_68_1968} in October of 1968 as he
had earlier promised the committee; at the same time, other members who
disagreed with the direction but had not resigned were also developing several
minority reports, include Dijkstra, Hoare, and Randell.
Sparing the reader the full details and political history of the ensuing committee
meetings, the final report \citetitle{report_on_the_algorithmic_language_algol_68_mailloux_1969}
was published in \textit{Numerische Mathematik} and \textit{Kybernetika}
in 1969, thus specifying what we know today to be ALGOL 68.

\subsection{The W-Grammar}

Before analyzing the technical details of ALGOL 68, we must first understand
what made it so offensive and uninterpretable to so many people: its grammar.

The primary reason for this grammar's complexity is that it encompasses
far more than compiler engineers typically associate with a grammar
in order to be \textit{formally context-sensitive}.
It is not merely a specification of the syntax of the language;
it also specifies a great deal of the \textit{semantics} of the language,
because that is required for the language to be context-sensitive.
When the grammar is described as \textit{two-level}, it communicates that the
grammar consists of two levels: the meta-grammar and the concrete grammar, and the
meta-grammar produces the concrete grammar.
Readers of [MR93] would need to keep track of both levels in order to understand
the document; meta-rules would need to be kept conceptually distinct in the reader's mind.
The \textit{format} of the grammar was also problematic and difficult to read,
but that may not have been so problematic had they not fit so many semantic concepts into the grammar.

When Wijngaarden first proposed his grammar, nobody had seen anything like it.
The authors attempted to formalize object lifetimes, variable scoping rules,
and relatively complicated type systems (even by today's standards), all without
the benefit of decades of research into type theory and formal semantics which
we have today.
Let the reader give the authors the benefit of the doubt; keep in mind they
attempted to formalize concepts for the first time, and subsequent research benefitted
greatly from their ideas (and mistakes).
The language specification was, effectively, a compiler front-end specification.

Lindsey argues that the grammar is relatively close to Prolog, where
goals and sub-goals are specified and solved for by unification
\footnote{The term \textit{unification} may be loaded; Milner did not publish
	his work on SML and type inference until later, though his work was inspired by
	ALGOL 68 to some degree.}.

Lindsey uses the following Prolog example to introduce a rule in ALGOL 68's W-grammar,
which asks whether the input program contains an assignation, and to determine this,
we must test if we have a destination, followed by some language construct that
becomes a symbol, followed by a source.

\begin{lstlisting}[language=prolog,frame=single]
assignation(ref(MODE)) :-
      destination(ref(MODE)), becomes_symbol, source(MODE).
\end{lstlisting}

The corresponding rule in the [MR93] draft report is as follows
\cite{draft_report_algol_1968}:
\begin{lstlisting}[frame=single]
MODE assignation :
    reference to MODE destination, becomes symbol, MODE source.
\end{lstlisting}

Substituting \textbfit{int} for our \textbfit{MODE}, we have:
\begin{lstlisting}[frame=single]
int assignation : reference to int destination, becomes symbol, int source.
\end{lstlisting}

If you squint your eyes, maybe you can see how \textit{i := 5} fits the mold for this
grammar, where the \textbfit{MODE} is \textbfit{int}, the \textbfit{destination} is
the location of \textbfit{i} of mode \textbfit{ref int}, and the source is
the integer literal \textbfit{5} of \textbfit{MODE int}.
This may feel familiar, like a looser version of the Backus-Naur
syntax used by compiler-compilers.
The problem is, nearly anything else is also expressible in this grammar,
making it nearly impossible to write a parser based on an unrestricted W-grammar.

A more nebulous component of the original grammar from [MR93] can be found in
\textit{Section 4.4 Context Conditions},
which specified conditions for a program to be \textit{semantically valid}
based on the surrounding context.
Modern readers may find this strange; we are discussing the language \textit{syntax},
why is the report discussing the semantic validity of, for example,
the use of a particular identifier and its relationship to its declaration?
As we have already established, this is an example of language \textit{semantics}
being specified in the grammar.

Most modern compilers are broken into three parts: the front-end, middle-end
\footnote{Only compiler engineers could produce a term as idiosyncratic as \textit{"middle" "end"}.},
and back-end.
The front-end typically consumes the input program,
produces data structures representing the program,
and performs \textit{semantic} analysis on those data structures to ensure the program is valid.
The consumption of the input program is usually determined by the grammar specified by the language,
and semantic validity is determined by the language's type system and other rules,
but not typically by the grammar.
Because Wijngaarden attempted to specify all of this in the grammar itself,
the grammar needed to specify these semantic conditions as well.

See this excerpt on \textbfit{NEST}s from
\cite[Section 3.0.2, Semantics]{revised_report_on_the_algorithmic_language_algol_68_1976}:
\begin{quotation}
	A "nest" is a 'NEST'. The nest "of" a construct is the "NEST" enveloped
	by the original of that construct, but not by any 'defining LAYER'
	contained in that original.

		{The nest of a construct carries a record of all the declarations forming
			the environment in which that construct is to be interpreted.

			Those constructs which are contained in a range R, but not in any
			smaller range contained within R, may be said to comprise a "reach". All
			constructs in a given reach have the same nest, which is that of the
			immediately surrounding reach with the addition of one extra "LAYER".
			The syntax ensures (3.2.1.b, 3.4.1.i,j,k, 3.5.1.e, 5.4.1.1.b) that each 'PROP'
			(4.8.1.E) or "property" in the extra 'LAYER' is matched by a defining.
			indicator (4.8.1.a) contained in a definition in that reach.}
\end{quotation}

Today, \textbfit{NEST}s might exist concretely as data structures inside the semantic analysis
phase of a compiler, but in ALGOL 68, they were specified as part of the grammar itself.

ALGOL 68's type system was also remarkably complex and, again, fully embedded in the grammar.
Union modes are full commutative and accumalative types, meaning that
the following types are equivalent:
\textbfit{union(int, real, bool)},
\textbfit{union(real, int, bool)}, and
\textbfit{union(bool, union(real, int))}.

Lindsey pointed out a particularly tricky aspect of the type system in structural equivalence.
Structure types are equivalent if their members are equivalent, as opposed to name equivalence,
which would have implied two structures with the same members but different names
are not equivalent.
The following two types are equivalent by structural comparison:
\begin{lstlisting}[language=algol,frame=single]
mode a = struct (int val, ref a next);
mode b = struct (int val, ref struct (int val, ref b next) next);
\end{lstlisting}



\subsection{Concepts of ALGOL 68}

Having covered the political machinery that resulted in the final report and
the grammar that caused the community so much grief,
we will now look to more technical details of the language.

Firstly, ALGOL 68 is an expression-oriented language;
there is fundamentally no distinction between statements and expressions,
allowing for constructs like the following:

\begin{lstlisting}[language=algol,frame=single]
x := (real a = p*q;
      real b = p/q;
      if a>b then a else b fi)
      + (y := 2*z);
\end{lstlisting}

There were numerous extensions to arrays, including higher-dimensional arrays,
complicated slicing mechanisms, and flexible arrays, such as the following:
\begin{lstlisting}[language=algol,frame=single]
loc[1:4, 1:5] int a45;
a45[2  ,    ] # row 2 #
a45[   , 3  ] # column 3 #
a45[2:3, 3  ] # part of column 3 #
a45[2:3, 2:4] # a little square in the middle.  #

loc flex [1:0] int array; # initially empty #
array := (1, 2, 3);       # now it has bounds [1:3] #
array := (4, 5, 6, 7, 8); # now it has bounds [1:5] #
\end{lstlisting}

Call-by-name as it was known in ALGOL 60 was removed in favor of
call-by-value and call-by-reference; some of the other proposals
(such as Seegm{\"u}ller's) preserved the two cases of call-by-name
under different terms, but this was not adopted.
One may argue that \textit{proceduring} is a form of call-by-name,
but this feature was removed in the revised report of 1973.

Call-by-name is really two different concepts:
call-by-reference (where the actual parameter is a named variable to
be assigned to) \textit{or} call-by-full-name (where the actual parameter
is an expression to be placed in a thunk and re-evaluated each time
it is used in the body of the callee). This meant that Jensen's Device
and other tricks made possible by call-by-name were no longer possible
in ALGOL 68.
Wirth's proposal included call-by-name untouched from ALGOL 60 alongside
a \textit{new} parameter passing mechanism called \textit{parameterless \textbf{procedure}}
parameters, meaning the parameters were thunks to be evaluated each time they
were used in the body of the callee\cite{a_history_of_algol_68_1993}.
Lindsey uses an inner-product algorithm to illustrate this:

\lstinputlisting[language=algol,frame=single]{chapters/dawn/inner-product.a68}

He notes that the first and second parameters are effectively both called by-name.
As far as I can tell, the only difference is that call-by-name parameters can
be l-values or r-values while parameterless procedures are always r-values.

There were at least eight changes to the automatic type conversion rules
between ALGOL 60 and ALGOL 68;
Lindsey had this remark about the automatic type conversion features:
\begin{quotation}
	Although coercions had existed in previous programming languages, it was ALGOL
	68 that introduced the term and endeavoured to make them a systematic feature
	(although it is often accused of a huge overkill in this regard).
\end{quotation}

Many of these coercion rules were uncontroversial; for example, a \textbfit{real}
may be assigned to a \textbfit{union(real, int)}.
\todo{Discuss \textit{rowing}? relates to rank polymorphism a bit...}
One particularly problematic coercion rule was \textit{proceduring}.
This allowed users to force call-by-name semantics by coercing an expression
into a parameterless procedure, like so:

\begin{lstlisting}[language=algol,frame=single]
      PROC x plus 1 = INT : x + 1;
\end{lstlisting}

The right hand side of this expression is a \textit{cast}
(a term originally coined for the specification of ALGOL)
of an integer expression into a procedure taking no arguments.
In \citetitle{algol68_with_fewer_tears_1968}\footnote{This paper was, in fact,
	a valid ALGOL 68 program in and of itself}, Lindsey argues that references
obviate the need for call-by-name semantics, but that call-by-substitution is what
ALGOL 60's call-by-name effectively was, and this was still possible with ALGOL 68
via this \textit{proceduring} coercion:

\begin{lstlisting}[language=algol,frame=single]
begin
proc series = (int k, ref int i, proc real term) real expr
    begin
    real sum(0);
    for j to k do
        begin i := j;
              sum plus term
        end;
    sum
    end

x := series (100, i, real expr(1/i));

# Or, via proceduring: #
x := series (100, i, 1/i);
\end{lstlisting}

This facility was abandoned in the ALGOL 68-R implementation which
led to its removal in the revised report of 1973,
as we will see in the next section.
There were still other mechanisms to achieve similar results,
as tricks like Jensen's Device had become important to the community.
One such example is the extensions to procedures.

Naur and Wirth both proposed block-expressions, meaning the final value in a block
is the value of the entire block in the context of an expression, and Naur's
1966 proposal (which was accepted) merged the formal parameters into the same line as
the parameters themselves, meaning one need not restate the types of parameters
at the beginning of the procedure body.
These two features allowed for convenient use of anonymous procedures capturing
parts of their surrounding context and procedures taking other procedures,
relatively advanced features even for today.
The revised report contains this example
\cite[Section 11.2, Innerproduct 1]{revised_report_on_the_algorithmic_language_algol_68_1976}:

\begin{lstlisting}[language=algol,frame=single]
proc innerproduct 1 = (int n, proc (int) real x, y) real:
      # the innerproduct of two vectors, each with 'n'
      comppnents, x (i), y (i), i = 1, ... , n, where 'x' and 'y'
      are arbitrary mappings from integer to real number #
      begin long real s := long 0;
            for i to n do s +:= leng x (i) \times leng y
(i) od;
            shorten s
      end

# Real-calls using innerproduct 1: #
      innerproduct 1 (m, (int j) real: x1[j], (int j) real: y1[i])
      innerproduct 1 (n, nsin, ncos)
\end{lstlisting}

\subsection{ALGOL 68-R and the Revised Report}

In 1973, the \citetitle{revised_report_on_the_algorithmic_language_algol_68_1976} was published,
codifying some of the changes and rejected features from the ALGOL 68-R team.

\todo{look at peck's \citetitlecite{the_algol_68_story_peck_1978}}

His work on ALGOL 68S was not an outlier amongst would-be implementers of the
language; because the report was so large and complex, most
implementers ended up restricting themselves to a subset of the language.

\subsection{Criticism of ALGOL 68}

Numerous committee members and readers of the \textit{ALGOL Bulletin} criticized
the original report for its complexity; Lindsey (our faithful defender of the
language) conceded that "much of the mud slung at [the original report] is
probably still sticking"\cite{a_history_of_algol_68_1993}.
Much of that complexity came from the

\todo{Defined in Wijngaarden Grammar by Adriaan van Wijngaarden.
	Contains parsing and things which in other langauges are called semantics.}

\todo{'68 critcized by Hoare and Dijkstra for abandoning simplicity of '60.
	In 1970, ALGOL 68-R became the first working compiler for ALGOL 68.}

\subsection{Legacy of ALGOL}

It is difficult to overstate the impact of the design decisions of both ALGOL 60 and 68,
even though neither saw widespread adoption in the industry outside depictions of
algorithms in academic papers.
When Dennis Ritchie extended Ken Thompson's B compiler with a type system, he drew heavy
inspiration from ALGOL 68:

\begin{quotation}
	The scheme of type composition adopted by C owes considerable debt to Algol 68,
	although it did not, perhaps, emerge in a form that Algol's adherents would
	approve of. The central notion I captured from Algol was a type structure based
	on atomic types (including structures), composed into arrays, pointers
	(references), and functions (procedures). Algol 68's concept of unions and
	casts also had an influence that appeared later.
	\cite{development_of_c_language_chist_ritchie_1996}
\end{quotation}

Lindsey points out a few others:

\begin{quotation}
	The type system of ALGOL 68 has been adopted, more or less faithfully, in many subsequent
	languages. In particular, the structs, the unions, the pointer types, and the parameter passing of C
	were influenced by ALGOL 68 [Ritchie 1993], although the syntactic sugar is bizarre and C is not so
	strongly typed. Another language with a related type system is SML [Milner 1990], particularly with
	regard to its use of ref types as its means of realizing variables, and C++ has also benefitted from the
	reftypes [Stroustrup 1996].
	\citetitle{a_history_of_algol_68_1993}
\end{quotation}

ALGOL 68 also had a notable influence in the Soviet Union, details of which can
be found in Andrey Terekhov's 2014 paper \citetitlecite{algol_68_ussr_2014}.

\todo{Pascal, Ada}
\todo{Lindsey: "So here are my recommendations to people who essay to design programming languages."
	\citetitlecite{a_history_of_algol_68_1993}}

\begin{quotation}
	An interesting observation is the fact that the two-level formalism used
	in the description of ALGOL 68 by itself led to a number of programming
	languages, including PROLOG (Colmerauer)\dots
	\cite{a_shorter_history_of_algol68_1994}
\end{quotation}
