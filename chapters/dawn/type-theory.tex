\section{Early Type Theory}

A surprising number of the foundations for type theory were laid before
many familiar programming concepts were developed.
Namely, Alonzo Church's \lambdacalc{} and Haskell Curry's combinatory logic
would set the foundation for type theory long before they would be implemented in
a proper compiler.

Let me digress for a moment before we begin.
We will also discuss the topics that I hold responsible for the general
bewilderment that most computer science students feel when they are first
introduced to programming concepts: the degree to which programming concepts
are arbitrary.
Computer science and software engineering are often taught like materials science,
where we have concrete methods for discovering and constructing new materials,
when in reality, programming is fundamentally built on \textit{information science},
not engineering.

When we superimpose meaning on the state of computers and the blueprints
we provide the computer in the form of code, we are not discovering new materials
but (often rather arbitrarily) assigning meaning based on analogies to the physical
world which may or may not be reflected in the machines themselves.
This is most obviously seen in object-oriented programming, where the state of
the machine is represented by objects and their platonic ideals so the programmer
can develop a more natural mental model of the machine.
The process of discovering which analogies work well for human comprehension
(and therefore which ones work well in compilers and programming language design)
is rather unscientific, and is often produced by programmers coming up with
ideas based on what works well in the field.

Type theory, category theory, information theory and the like all underpin
these decisions because they are also built entirely on top of information.
This is the reason information theoriests and category theorists are so
influential in the history of programming language design, and why their
work is often bewildering to programmers without a formal background
in these fields--even very experienced ones.

This section may therefore feel foreign--it still feels that way to me--
but the reader is encouraged to glean what they can from it, and not be too
troubled by what they cannot.

\subsection{Alonzo Church and the \Lambdacalc{}}

We will not given an exhaustive look at Church's life and work outside of the
\lambdacalc{}--I encourage readers to consult \citetitlecite{stanford_encyclopedia_church_2025}
for this.
He is renowned for more than just the \lambdacalc{} though we will not cover much more
than that here.

All throughout the 1930s, Church developed the \textit{\lambdacalc{}},
a formal definition of a \textit{higher-order, functional} programming language
built on only three concepts: functions, variables, and application.
The language was \textit{higher-order} in that functions could be passed
as arguments to other functions, and functions could return other functions as results.
It was \textit{functional} in that function definition and application was the
primary abstraction in the language.

In the \lambdacalc{}, functions are given by $\lambda x. E$ where $x$ is the function's argument
and $E$ is the resulting expression. The result of the function is given by substituting the
argument for all occurances of $x$ in $E$. Function application is given by juxtaposition,
so $F x$ applies the function $F$ to the argument $x$.

Function definitions and applications are all assumed to take exactly one argument,
though there are syntaxes given for more:

\begin{align}
	\lambda x . (\lambda y . (\lambda z . E)) & \equiv \lambda x y z . E
	\tag{function definition}
	\\
	M N P x                                   & \equiv M (N (P x))
	\tag{function application}
\end{align}

In 1940, he published \citetitle{church_simple_theory_of_types_1940}
which would become the foundation for type theory.

The \lambdacalc{}

\subsection{Haskell Curry}

\todo{not sure how much we want to cover here}...
\citetitle{curry_functionality_in_combinatory_logic_1934}.
