\section{The Introduction of \Lambdacalc{}}
\label{sec:intro-lambda-calc}

A surprising number of the foundations for programming language
theory were laid before
many familiar programming concepts were developed.
Higher-order logic, combinatory logic, and \lambdacalc{} were
all being developed prior to their uses in programming languages
with the aim of providing a firm foundation for \textit{mathematics},
and would only cross-polinate with programming languages later on.

Let me digress for a moment before we begin.
Students of computer science often feel a sense of bewilderment
when they are first introduced to many foundational concepts
in a way that is unique to the field
\footnote{You will have to take my word on this. I provide no evidence,
	but I believe readers will come to agree.}.
I believe the reason for this is that the field is directly built
upon information theory and higher-order logic, fields which were
only recently developed in the history of mathematics, and contain
some unsettling and bewildering concepts.

In the early 20\textsuperscript{th}, Russell's paradox was recently developed
and Gödel's incompleteness theorems were not.
For those unfamiliar, they call into question the validity of the foundations
of mathematics and point out the limits of provability.
These led to several efforts to establish a firm foundation for the entire
field of mathematics, some of which were based on sets and other functions
and the two that we concern ourselves with here are \textit{combinatory logic}
(abbreviated \textit{\acrshort{cl}} from here) and \lambdacalc{} (occasionally abbreviated \lam{}),
which were attempts to use functions.
They are closely related and share many concepts.
These efforts directly led to functional programming and type theory,
and underpin many other concepts in programming languages and compilers.

I am no expert in this field and it does not entirely concern the history
of compilers, but we will digress insofar as it informs our focus.

\subsection{\acrlong{cl} and \Lambdacalc{}}

Both \lam{} and \acrshort{cl} were invented in the 1920s--
\acrshort{cl} first by the Ukrainian mathematician Moses Schönfinkel
at the University of Göttingen
(likely the most advanced mathematics institution at the time).
He introduced the concepts informally in a talk in 1920, and the ideas
were first published in \citep{schonfinkel_invented_cl_building_blocks_math_1967}.

\subsection{todo: history of \Lambdacalc{}}
\citetitle{cardone_hindley_history_of_lambda_calcl_2006}
\citetitle{hindley_lambda_calc_intro_2008}
\citeauthor{cardone_hindley_history_of_lambda_calcl_2006}

history of lambda calc:
Both lambdacalc and combinatory logic were invented in the 1920s.
Describe most basic properties of functions. logical foundation of math was
real fluid in early 19thc. Russell's paradox was recent G{\"o}del's theorems
not known yet, still developing the foundations of math.
Some were based on sets, some based on functions, all up in the air.
lambda and CL were developed here, build higher concepts of functions
based only on these two foundations.
<cardone> describe as chassis of bus in prog langs.
lambda/cl gain purpose in these systems, like chassis; underpins things
and isnt seen, doesn't have much value on its own.
function-based higher-order logic is the real context, but we're already so far off
topic and I'd like to get back to compilers soon as I can.
Lots was developed in the 20s and 30s, then not much till the 60s
largely cuz of connections with prog langs.
notations for higher-order thinking about functions dates earlier,
at least 1889 Giuseppe Peano on axioms for arithmetic.
was not until Moses Sch{\"o}nfinkel developed basic combinators
for functions (1924 sec 1) that we start to get combinatory logic.
at gottingen germany, prob top math research group of the period.
Pointed out f(x,y) could be (f(x))(y) where f returns func,
now known as "currying." curry attributed to Scho.. many times but the name
stuck.
that was the last thing scho published on combinators, and by 1927 he was said
to be mentally ill and institutionalized.

his ideas cropped up again in jv neumann doctoral thesis
on foundations of set theory (neumann 1025) but it was really function-based
not set-based, and his axioms contained combinator-like operators (p225).
not sure if JVN got this from scho or not, he didn't mention him
and his ideas looked really different.
next step in CL: haskell curry re-invented combinators.

6.1 lisp
1956-60 mccarthy lisp w function-abstraction.
didn't have numbers, but just like lambda calc.
substitution was not like lambdacalc bc dynamic binding, which helped
interpreters but made programming really complicated.
mccarthy contributed some back, including cond-exprs in functional formalism.

6.2 peter landin
early 60s PL proposed lambda terms to make constructs of a programming language
algol 60 (landin 1965).
algol block structure/identifier semantics matched lambdacalc, allowed
ppl to look at lambda as a programming langauge.
in parallel with this algol stuff, landin 1963 abstract machine
for reducing lambda terms SECD-machine (1964, 1966a) of 4 components:
stack for intermediate results, environment, control (code) driving the process
and dump for showing the state of the program.
the rules of his machine used call-by-value.
would be followed up by further considerations of lambdacalc as a prog lang
(Plotkin 1975).
For the most part, other than McCarthy's papers,
CL/lambda contributed to proglangs but not the other way around,
until Corrado Bohm from 1960s on.
bohm phd thesis w first description of complete compiler written in its own language
	[bohm 1954].

encoding of operations of iversons APL marisa venturini zilli 1962-64.
gotta summarize bohm.
james morris MIT 1968 thesis, untyped and simply typed lambda calculus.
substitution had to be reconsidered in lambda calculus and CL cuz Lisp
necessitated the efficient implementation of these algorithms, not just
theoretical.

8 types: russel whitehead's principia mathematica.
Types were there before they came up in programming languages bigtime,
but they werent fully deployed until later. so we start with lambdaclac and CL
and then we'll do type theory in Software section.
1967 los angeles set theory symposium [Lawvere, 1969a].

% -----

Throughout the 1930s, Church developed the \textit{\lambdacalc{}},
a formal definition of a \textit{higher-order, functional} programming language
built on only three concepts: functions, variables, and applications.
The language was \textit{higher-order} in that functions could be passed
as arguments to other functions, and functions could return other functions as results.
It was \textit{functional} in that function definition and application was the
primary abstraction in the language.

In the \lambdacalc{}, functions are given by $\lambda x. E$ where $x$ is the function's argument
and $E$ is the resulting expression. The result of the function is given by substituting the
argument for all occurances of $x$ in $E$. Function application is given by juxtaposition,
so $F x$ applies the function $F$ to the argument $x$.

Function definitions and applications are all assumed to take exactly one argument,
though there are syntaxes given for more:

\begin{align}
	\lambda x . (\lambda y . (\lambda z . E)) & \equiv \lambda x y z . E
	\tag{function definition}
	\\
	M N P x                                   & \equiv M (N (P x))
	\tag{function application}
\end{align}

In 1940, he published \citetitle{church_simple_theory_of_types_1940}
which would become the foundation for type theory.

The \lambdacalc{}

\subsection{Haskell Curry}

\todo{not sure how much we want to cover here}...
\citetitle{curry_functionality_in_combinatory_logic_1934}.
