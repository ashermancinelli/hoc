\chapter{Codesign}

In each age, contemporaries have attempted to place their work in the overarching history of computing,
and some have attempted to look forward and guess at the field's future;
in either case, they are often wrong.
Computing is a young, volatile industry, and it is often much easier to place
place a time period in history retrospectively than it is to do so in the moment.
Nonetheless, this is what I will attempt to do in this chapter.
I am writing about compilers here in the 2020s, the time period in which I work on compilers.
Out of hubris I will attempt to contextualize today's compiler work in the context of history.
Please let my future readers be forgiving.

\begin{quotation}
But there are still lots of interesting open problems left and one of the most intriguing aspects of
compiler design is can we use AI, machine learning, and large language models like GPT-3 to create
code automatically from written or spoken specifications. That's still an unfolding story and I'm not willing
to trust any program created by an AI program at this point. I wouldn't want it in my pacemaker. I wouldn't
want it in my self-driving car or in my airplane. But maybe for a computer game, it's okay. This is what
they're creating with these at this time. So even the area of programming language translation is
undergoing new approaches and how successful they will be is yet to be determined.
\cite{aho_oral_history_2022}
\end{quotation}

\section{Accellerators}
\section{MLIR}
