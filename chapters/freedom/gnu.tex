\section{GNU}
\label{sec:gnu}

In the 1980s, business models centered on software had grown substantially
and the Unix programming environment began permeating the industry,
bringing the C programming language along with it.
The commercialization of software has obvious advantages and disadvantages:
it is convenient that people can make a living off of writing software,
but it often stifles the collaborative environment that compilers
and programming languages grew out of.
The reaction to the commercialization of software was strong and
wiped out many companies and teams within companies dedicated to
compiler development while centering the industry around a standard,
free set of tools.

\subsection{Richard Stallman}

Richard Stallman attended Harvard in 1970, pursuing a bachelor's degree in physics.
At the end of his first year there, he began attending the MIT Artificial Intelligence Lab,
where Lisp was developed (\cref{sec:lisp}).
After graduating from Harvard in 1974, he joined the MIT lab as a graduate student.
This only lasted for a year, at which point he dropped out and began
working at the lab full-time \parencite{gross_stallman_interview_1999}.

Shortly after he began working full-time, many of the original hackers that
drew him to MIT began starting their own companies
and hiring away the other hackers at MIT.
The two most significant companies were Symbolics and \textit{Lisp Machines, Inc.} (LMI),
both set out to build \gls{lisp-machine}s and Lisp-based operating systems
based on their founder's experience working with Lisp at MIT.

Both companies attempted some level of collaboration with MIT,
to the extent that Symbolics and LMI both \textit{continued to use MIT's machines
	and source code}, which led to intellectual property disagreements.
Symbolics eventually reached an agreement with MIT such that MIT would continue
to benefit from Symbolic's Lisp machine developments \textit{only as users},
and members of MIT were not allowed to view Symbolic's source code.

In an effort to maintain MIT's hacking culture, Stallman sought to replicate
\footnote{Initially, Stallman read Symbolics' source code instead of
	replicating their features from scratch;
	\citeauthor{weinreb_symbolics_history_2020} understood Stallman's prior
	statements to mean that he did not read Symbolics' source code,
	which he pointed out in \parencite{weinreb_symbolics_history_2020},
	and Stallman left a footnote in
	\parencite[footnote 7]{stallman_my_lisp_experiences_2002}
	noting that Symbolics' source code was made available to MIT and he re-implemented
	their features before eventually deciding against even reading it.}
Symbolics' Lisp machine developments as they came out, such that the software
available to MIT would keep feature parity with that of the commercial products.
This benefited LMI, since they were allowed to see and use MIT's Lisp code.
Stallman \footnote{Again, this is Stallman's word against Weinreb's.
	There are many conflicting accounts.} kept LMI in business out of spite
for Symbolics, because he percieved them to have taken away his community.

\subsection{Birth of GNU}

Stallman tired of attempting to punish Symbolics and began considering
what he should do next.
By mid-1983, Stallman had considered building a new community around
a free operating system similar to Unix, GNU, for \textit{GNU's Not Unix}.
He no longer worked for MIT, but he was still able to use their systems.

While the first and primary program he worked on for GNU
was the GNU Emacs editor (which he rewrote after developing the original Emacs
at MIT, which he took over from Guy Steele
\parencite[footnote 1]{stallman_my_lisp_experiences_2002}),
the GNU C compiler followed quickly.

The GNU C compiler

\begin{quotation}
	GCC, or rather, the idea for it, actually predates the GNU Project. In late 1983, just before he started
	the GNU Project, Richard M. Stallman, president of the Free Software Foundation and originator of the
	GNU Project, heard about a compiler named the Free University Compiler Kit (known as VUCK) that
	was designed to compile multiple languages, including C, and to support multiple target CPUs. Stallman
	realized that he needed to be able to bootstrap the GNU system and that a compiler was the first
	strap he needed to boot. So he wrote to VUCK’s author asking if GNU could use it. Evidently, VUCK’s
	developer was uncooperative, responding that the university was free but that the compiler was not.
	As a result, Stallman concluded that his first program for the GNU Project would be a multilanguage,
	cross-platform compiler.
	\parencite{von_hagen_definitive_guide_gcc_2011}
\end{quotation}

% ===================

There were loads of small companies that made money leasing out their compilers,
and GNU put them all out of business essentially overnight.
Every hardware company wrote their own compilers, but once it became clear
that just adding a backend for the GNU compiler would be significantly easier
than writing a new compiler from scratch, many of the hundreds of small compiler
companies went out of business, and the compiler teams inside large companies
began using and contributing to the GNU compilers.

In \cref{chap:software}, we discussed how the C programming language permeated
the software industry via Unix.
Hardware vendors would then develop their own C compilers so their users
could use the programming language they were familiar with, similar to how
hardware vendors were expected to provide Fortran compilers.
This led to a diverse ecosystem of C compilers from different vendors targeting
their respective hardware with an unfortunately diverse set of supported language features.
This meant users could not rely on a consistent experience with C compilers when
developing software for different hardware platforms.

The \textit{automake} and \textit{autoconf} tools were developed to address this
issue with macros, but buy-and-large, this experience was unpleasant for users.
