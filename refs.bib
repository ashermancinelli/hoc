
% Wikipedia has been a useful collection of primary and secondary sources
% https://en.wikipedia.org/wiki/History_of_compiler_construction#cite_ref-8
% https://en.wikipedia.org/wiki/History_of_programming_languages
% https://en.wikipedia.org/wiki/Timeline_of_programming_languages

@book{new_history_of_modern_computing,
	address = {Cambridge [Massachusetts]},
	series = {History of Computing},
	title = {A New History of Modern Computing},
	isbn = {9780262542906},
	abstract = {"Bringing the history of modern computing fully up to date, from new applications to scientific computation to video games and the ubiquitous smartphone"},
	language = {eng},
	publisher = {The MIT Press},
	author = {Haigh, Thomas and Ceruzzi, Paul E.},
	year = {2021},
}

@misc{did_grace_hopper_create_the_first_compiler_2022,
	title = {Did {Grace} {Hopper} {Create} the {First} {Compiler}? {Communications} of the {ACM}},
	shorttitle = {Did {Grace} {Hopper} {Create} the {First} {Compiler}?},
	url = {https://cacm.acm.org/blogcacm/did-grace-hopper-create-the-first-compiler/},
	language = {en-US},
	urldate = {2025-10-04},
	month = dec,
	year = {2022},
    author = {Bruderer, Herbert}
}

@book{kernighan_unix:_2020,
	address = {s. l.},
	title = {{UNIX}: a history and a memoir},
	isbn = {9781695978553},
	shorttitle = {{UNIX}},
	language = {eng},
	publisher = {Kindle Direct Publishing},
	author = {Kernighan, Brian W.},
	year = {2020},
}

@inproceedings{bauer_software_1968,
	address = {Garmisch, Germany},
	title = {SOFTWARE ENGINEERING},
	booktitle = {SOFTWARE ENGINEERING},
	url = {https://www.scrummanager.com/files/nato1968e.pdf},
	publisher = {NATO SCIENCE COMMITTEE},
	author = {Bauer, Friedrick and Naur, Peter and Randell, Brian},
	month = oct,
	year = {1968},
}

@misc{numba_cuda,
    author = {{NVIDIA Corporation}},
    title = {Numba CUDA},
	shorttitle = {Numba CUDA},
    year = {2024},
    publisher = {GitHub},
    howpublished = {\url{https://github.com/NVIDIA/numba-cuda/}},
    urldate = {2025-10-04},
    note = {The CUDA target for Numba}
}

@misc{jax-compiler,
  author = {JAX Authors},
  howpublished = {\url{https://github.com/jax-ml/jax}},
  title = {JAX: High performance array computing},
  year = {2024}
}

@inproceedings{lam_numba,
	address = {Austin Texas},
	title = {Numba: a {LLVM}-based {Python} {JIT} compiler},
	isbn = {9781450340052},
	shorttitle = {Numba},
	url = {https://dl.acm.org/doi/10.1145/2833157.2833162},
	doi = {10.1145/2833157.2833162},
	language = {en},
	urldate = {2025-10-04},
	booktitle = {Proceedings of the {Second} {Workshop} on the {LLVM} {Compiler} {Infrastructure} in {HPC}},
	publisher = {ACM},
	author = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
	month = nov,
	year = {2015},
	pages = {1--6},
}

@inproceedings{triton_tillet,
	address = {Phoenix AZ USA},
	title = {Triton: an intermediate language and compiler for tiled neural network computations},
	isbn = {9781450367196},
	shorttitle = {Triton},
	url = {https://dl.acm.org/doi/10.1145/3315508.3329973},
	doi = {10.1145/3315508.3329973},
	language = {en},
	urldate = {2025-10-04},
	booktitle = {Proceedings of the 3rd {ACM} {SIGPLAN} {International} {Workshop} on {Machine} {Learning} and {Programming} {Languages}},
	publisher = {ACM},
	author = {Tillet, Philippe and Kung, H. T. and Cox, David},
	month = jun,
	year = {2019},
	pages = {10--19},
}

@inproceedings{llvm,
author = {Lattner, Chris and Adve, Vikram},
title = {LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation},
year = {2004},
isbn = {0769521029},
publisher = {IEEE Computer Society},
address = {USA},
abstract = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
booktitle = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
pages = {75},
location = {Palo Alto, California},
series = {CGO '04}
}

@inproceedings{mlir,
  author={Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},
  booktitle={2021 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)}, 
  title={MLIR: Scaling Compiler Infrastructure for Domain Specific Computation}, 
  year={2021},
  volume={},
  number={},
  pages={2-14},
  keywords={Program processors;Buildings;Semantics;Hardware;Software;Generators;Optimization},
  doi={10.1109/CGO51591.2021.9370308}}

@inbook{hopl_backus_history_of_fortran,
author = {Backus, John},
title = {The history of Fortran I, II, and III},
year = {1978},
isbn = {0127450408},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800025.1198345},
booktitle = {History of Programming Languages},
pages = {25–74},
numpages = {50}
}

@inbook{hopl_keynote,
author = {Hopper, Grace},
title = {Keynote Address},
year = {1978},
isbn = {0127450408},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://dl.acm.org/doi/pdf/10.1145/800025.1198341},
booktitle = {History of Programming Languages},
pages = {25–74},
numpages = {50}
}

@inproceedings{rosen_altac_fortran_1961,
author = {Rosen, Saul},
title = {ALTAC, FORTRAN, and compatibility},
year = {1961},
isbn = {9781450373883},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800029.808498},
doi = {10.1145/800029.808498},
abstract = {One of the major aims in the development of universal or common problem-oriented languages has been to permit a user to make the transition from one computer to another without the necessity of a complete reprogramming job.The ALTAC compiler, compatible with FORTRAN II, has been used to implement such a transition from the IBM 704 to the PHILCO 2000 at a number of installations. To the best of my knowledge this is the first time that a compiler has assumed the major burden of transition from a large scale computer of one manufacturer to an even larger scale computer of another manufacturer.},
booktitle = {Proceedings of the 1961 16th ACM National Meeting},
pages = {22.201–22.204},
series = {ACM '61}
}

@misc{noauthor_biography_nodate,
	title = {Biography of {Grace} {Murray} {Hopper} {\textbar} {Office} of the {President}},
	url = {https://president.yale.edu/biography-grace-murray-hopper},
	language = {en},
	urldate = {2025-10-04},
	year = {2025},
}

@article{bellia_hierarchical_1981,
	title = {Hierarchical development of programming languages},
	volume = {18},
	copyright = {http://www.springer.com/tdm},
	issn = {0008-0624, 1126-5434},
	url = {http://link.springer.com/10.1007/BF02576358},
	doi = {10.1007/BF02576358},
	language = {en},
	number = {3},
	urldate = {2025-10-04},
	journal = {Calcolo},
	author = {Bellia, M.},
	month = sep,
	year = {1981},
	pages = {219--254},
}

@book{bentley_digitized:_2012,
	address = {Oxford},
	title = {Digitized: the science of computers and how it shapes our world},
	isbn = {9780199693795},
	shorttitle = {Digitized},
	abstract = {In this book the author tells the story of computer science, explaining how and why computers were invented, how they work, looking at real-world examples of computers in use, and considering what will happen in the future. There's a hidden science that affects every part of your life. You are fluent in its terminology of email, WiFi, social networking, and encryption. You use its results when you make a telephone call, access the Internet, use any factory-produced product, or travel in any modern car. The discipline is so new that some prefer to call it a branch of engineering or mathematics. But it is so powerful and world-changing that you would be hard-pressed to find a single human being on the planet unaffected by its achievements. The science of computers enables the supply and creation of power, food, water, medicine, transport, money, communication, entertainment, and most goods in shops. It has transformed societies with the Internet, the digitization of information, mobile phone networks and GPS (Global Positioning System) technologies. Here, the author explores how this young discipline grew from its theoretical conception by pioneers such as Turing, through its growth spurts in the Internet, its difficult adolescent stage where the promises of Artificial Intelligence (AI) were never achieved and dot-com bubble burst, to its current stage as a (semi)mature field, now capable of remarkable achievements. Charting the successes and failures of computer science through the years, he discusses what innovations may change our world in the future},
	language = {eng},
	publisher = {Oxford university press},
	author = {Bentley, Peter J.},
	year = {2012},
}

@article{10.1145/99164.99179,
author = {Whitfield, D. and Soffa, M. L.},
title = {An approach to ordering optimizing transformations},
year = {1990},
issue_date = {Mar. 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {25},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/99164.99179},
doi = {10.1145/99164.99179},
abstract = {As an approach to deriving an application order of optimizing transformations, a framework is developed for examining the interactions of the transformations. The framework is based on an axiomatic specification technique and includes both pre-conditions and post conditions that must exist before and after applying optimizations. For a selected set of optimizations, the framework is used to determine those interactions among the optimizations that can create conditions and those that can destroy conditions for applying other optimizations. From these interactions, an application order is derived to obtain the potential benefits of the optimizations that can be applied to a program. In some cases, the ordering of a pair of optimizations is unambiguous in that one optimization can either create or destroy the conditions for the other. In the few cases where there is a cyclic interaction, the ordering is resolved based on the perceived importance of the two optimizations.},
journal = {SIGPLAN Not.},
month = feb,
pages = {137–146},
numpages = {10}
}

@article{bacon_compiler_1994,
author = {Bacon, David F. and Graham, Susan L. and Sharp, Oliver J.},
title = {Compiler transformations for high-performance computing},
year = {1994},
issue_date = {Dec. 1994},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {4},
issn = {0360-0300},
url = {https://doi.org/10.1145/197405.197406},
doi = {10.1145/197405.197406},
abstract = {In the last three decades a large number of compiler transformations for optimizing programs have been implemented. Most optimizations for uniprocessors reduce the number of instructions executed by the program using transformations based on the analysis of scalar quantities and data-flow techniques. In contrast, optimizations for high-performance superscalar, vector, and parallel processors maximize parallelism and memory locality with transformations that rely on tracking the properties of arrays using loop dependence analysis.This survey is a comprehensive overview of the important high-level program restructuring techniques for imperative languages, such as C and Fortran. Transformations for both sequential and various types of parallel architectures are covered in depth. We describe the purpose of each transformation, explain how to determine if it is legal, and give an example of its application.Programmers wishing to enhance the performance of their code can use this survey to improve their understanding of the optimizations that compilers can perform, or as a reference for techniques to be applied manually. Students can obtain an overview of optimizing compiler technology. Compiler writers can use this survey as a reference for most of the important optimizations developed to date, and as bibliographic reference for the details of each optimization. Readers are expected to be familiar with modern computer architecture and basic program compilation techniques.},
journal = {ACM Comput. Surv.},
month = dec,
pages = {345-420},
numpages = {76},
keywords = {vectorization, superscalar processors, parallelism, optimization, multiprocessors, locality, dependence analysis, compilation}
}

@misc{henry_comp.compilers:_nodate,
	title = {Comp.compilers: {Re}: {History} and evolution of compilers},
	url = {https://compilers.iecc.com/comparch/article/97-10-017},
	abstract = {From comp.compilers newsgroup: Re: History and evolution of compilers},
	urldate = {2025-10-04},
	author = {Henry, Spencer},
	year = {1997},
}

@misc{norman_grace_nodate,
	title = {Grace {Hopper} and {Colleagues} {Introduce} {COBOL}},
	url = {https://www.historyofinformation.com/detail.php?id=778},
	author = {Norman, Jeremy},
	year = {1959},
}

@book{laplante_encyclopedia_2017,
	address = {BOCA RATON},
	edition = {Second edition.},
	title = {Encyclopedia of computer science and technology. {Volume} {II}, {Fuzzy}-{XML}},
	isbn = {9781315115887},
	abstract = {This book covers all aspects of computer science, engineering, and technology. It includes computer scientists, computer engineers computing professionals, managers, software professionals, and other technology professionals.},
	language = {eng},
	publisher = {CRC Press},
	author = {Laplante, Phillip A.},
	year = {2017},
	note = {OCLC: 1032027866},
	keywords = {Information technology Encyclopedias, Computer science Encyclopedias},
}

@article{landin_next_1966,
	title = {The next 700 programming languages},
	volume = {9},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/365230.365257},
	doi = {10.1145/365230.365257},
	abstract = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language.
            The system is biased towards “expressions” rather than “statements.” It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
	language = {en},
	number = {3},
	urldate = {2025-10-04},
	journal = {Communications of the ACM},
	author = {Landin, P. J.},
	month = mar,
	year = {1966},
	pages = {157--166},
}

@article{10.1145/321992.322001,
author = {Aho, A. V. and Johnson, S. C. and Ullman, J. D.},
title = {Code Generation for Expressions with Common Subexpressions},
year = {1977},
issue_date = {Jan. 1977},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/321992.322001},
doi = {10.1145/321992.322001},
abstract = {This paper shows the problem of generating optimal code for expressions containing common subexpressions is computationally difficult, even for simple expressions and simple machines. Some heuristics for code generation are given and their worst-case behavior is analyzed. For one register machines, an optimal code generation algorithm is given whose time complexity is linear in the size of an expression and exponential only in the amount of sharing.},
journal = {J. ACM},
month = jan,
pages = {146–160},
numpages = {15}
}

@book{10.5555/6448,
author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
title = {Compilers: principles, techniques, and tools},
year = {1986},
isbn = {0201100886},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}

@article{10.1145/29873.29875,
author = {Allen, Randy and Kennedy, Ken},
title = {Automatic translation of FORTRAN programs to vector form},
year = {1987},
issue_date = {Oct. 1987},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {4},
issn = {0164-0925},
url = {https://doi.org/10.1145/29873.29875},
doi = {10.1145/29873.29875},
abstract = {The recent success of vector computers such as the Cray-1 and array processors such as those manufactured by Floating Point Systems has increased interest in making vector operations available to the FORTRAN programmer. The FORTRAN standards committee is currently considering a successor to FORTRAN 77, usually called FORTRAN 8x, that will permit the programmer to explicitly specify vector and array operations.Although FORTRAN 8x will make it convenient to specify explicit vector operations in new programs, it does little for existing code. In order to benefit from the power of vector hardware, existing programs will need to be rewritten in some language (presumably FORTRAN 8x) that permits the explicit specification of vector operations. One way to avoid a massive manual recoding effort is to provide a translator that discovers the parallelism implicit in a FORTRAN program and automatically rewrites that program in FORTRAN 8x.Such a translation from FORTRAN to FORTRAN 8x is not straightforward because FORTRAN DO loops are not always semantically equivalent to the corresponding FORTRAN 8x parallel operation. The semantic difference between these two constructs is precisely captured by the concept of dependence. A translation from FORTRAN to FORTRAN 8x preserves the semantics of the original program if it preserves the dependences in that program.The theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form. Dependence is defined and characterized in terms of the conditions that give rise to it; accurate tests to determine dependence are presented; and transformations that use dependence to uncover additional parallelism are discussed.},
journal = {ACM Trans. Program. Lang. Syst.},
month = oct,
pages = {491–542},
numpages = {52}
}

@book{10.5555/1097042,
author = {Cocke, John},
title = {Programming languages and their compilers: Preliminary notes},
year = {1969},
isbn = {B0007F4UOA},
publisher = {New York University},
address = {USA}
}

@techreport{allen_catalogue_1971,
	title = {A {Catalogue} of {Optimizing} {Transformations}},
	url = {https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf},
	institution = {IBM J Watson Research Center},
	author = {Allen, Francis and Cocke, John},
	year = {1971},
}

@inproceedings{backus_fortran_1957,
	address = {Los Angeles, California},
	title = {The {FORTRAN} automatic coding system},
	copyright = {https://www.acm.org/publications/policies/copyright\_policy\#Background},
	url = {http://portal.acm.org/citation.cfm?doid=1455567.1455599},
	doi = {10.1145/1455567.1455599},
	language = {en},
	urldate = {2025-10-04},
	booktitle = {Papers presented at the {February} 26-28, 1957, western joint computer conference: {Techniques} for reliability on - {IRE}-{AIEE}-{ACM} '57 ({Western})},
	publisher = {ACM Press},
	author = {Backus, J. W. and Stern, H. and Ziller, I. and Hughes, R. A. and Nutt, R. and Beeber, R. J. and Best, S. and Goldberg, R. and Haibt, L. M. and Herrick, H. L. and Nelson, R. A. and Sayre, D. and Sheridan, P. B.},
	year = {1957},
	pages = {188--198},
}

@book{the_first_computers_2002,
author = {Rojas, Raul and Hashagen, Ulf},
title = {The  First Computers: History and Architectures},
year = {2002},
isbn = {0262681374},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
abstract = {From the Publisher:This history of computing focuses not on chronology (what came first and who deserves credit for it) but on the actual architectures of the first machines that made electronic computing a practical reality. The book covers computers built in the United States, Germany, England, and Japan. It makes clear that similar concepts were often pursued simultaneously and that the early researchers explored many architectures beyond the von Neumann architecture that eventually became canonical. The contributors include not only historians but also engineers and computer pioneers. An introductory chapter describes the elements of computer architecture and explains why "being first" is even less interesting for computers than for other areas of technology. The essays contain a remarkable amount of new material, even on well-known machines, and several describe reconstructions of the historic machines. These investigations are of more than simply historical interest, for architectures designed to solve specific problems in the past may suggest new approaches to similar problems in today's machines.}
}

@article{10.1145/361454.361515,
author = {Bauer, F. L. and W\"{o}ssner, H.},
title = {The “Plankalk\"{u}l” of Konrad Zuse: a forerunner of today's programming languages},
year = {1972},
issue_date = {July 1972},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/361454.361515},
doi = {10.1145/361454.361515},
abstract = {Plankalk\"{u}l was an attempt by Konrad Zuse in the 1940's to devise a notational and conceptual system for writing what today is termed a program. Although this early approach to a programming language did not lead to practical use, the plan is described here because it contains features that are standard in today's programming languages. The investigation is of historical interest; also, it may provide insights that would lead to advancements in the state of the art. Using modern programming terminology, the Plankalk\"{u}l is presented to the extent it has been possible to reconstruct it from the published literature.},
journal = {Commun. ACM},
month = jul,
pages = {678–685},
numpages = {8},
keywords = {higher programming languages, history of programming, programming, theory of programming}
}

@inbook{konrad_zuses_z4_2000,
author = {Speiser, Ambros P.},
title = {Konrad Zuse's Z4: architecture, programming, and modifications at the ETH Zurich},
year = {2000},
isbn = {0262181975},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
booktitle = {The First Computers: History and Architectures},
pages = {263–276},
numpages = {14}
}

@inbook{notation_as_a_tool_of_thought_2007,
author = {Iverson, Kenneth E.},
title = {Notation as a tool of thought},
year = {2007},
isbn = {9781450310499},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1283920.1283935},
booktitle = {ACM Turing Award Lectures},
pages = {1979}
}

@article{goldstine_annals_1980,
	title = {\textit{{Annals} of the {History} of {Computing}} . {Bernard} {A}. {Galler}},
	volume = {71},
	issn = {0021-1753, 1545-6994},
	url = {https://www.journals.uchicago.edu/doi/10.1086/352427},
	doi = {10.1086/352427},
	language = {en},
	number = {1},
	urldate = {2025-10-05},
	journal = {Isis},
	author = {Goldstine, Herman H.},
	month = mar,
	year = {1980},
	pages = {160--160},
}

@inbook{nothing_new_since_von_neumann_2000,
author = {Ceruzzi, Paul},
title = {“Nothing new since von Neumann”: a historian looks at computer architecture, 1945–1995},
year = {2000},
isbn = {0262181975},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
booktitle = {The First Computers: History and Architectures},
pages = {195–217},
numpages = {23}
}

@article{can_programming_be_liberated_from_the_von_neumann_style_1978,
author = {Backus, John},
title = {Can programming be liberated from the von Neumann style? a functional style and its algebra of programs},
year = {1978},
issue_date = {Aug. 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/359576.359579},
doi = {10.1145/359576.359579},
abstract = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor—the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs.An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose “unknowns” are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs.A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states—only one state transition occurs per major computation.},
journal = {Commun. ACM},
month = aug,
pages = {613–641},
numpages = {29},
keywords = {algebra of programs, applicative computing systems, applicative state transition systems, combining forms, functional forms, functional programming, metacomposition, models of computing systems, program correctness, program termination, program transformation, programming languages, von Neumann computers, von Neumann languages}
}

@book{grace_hopper_and_the_invention_of_the_information_age_2009,
author = {Beyer, Kurt W.},
title = {Grace Hopper and the Invention of the Information Age},
year = {2009},
isbn = {026201310X},
publisher = {The MIT Press},
abstract = {A Hollywood biopic about the life of computer pioneer Grace Murray Hopper (19061992) would go like this: a young professor abandons the ivy-covered walls of academia to serve her country in the Navy after Pearl Harbor and finds herself on the front lines of the computer revolution. She works hard to succeed in the all-male computer industry, is almost brought down by personal problems but survives them, and ends her career as a celebrated elder stateswoman of computing, a heroine to thousands, hailed as the inventor of computer programming. Throughout Hopper's later years, the popular media told this simplified version of her life story. In Grace Hopper and the Invention of the Information Age, Kurt Beyer goes beyond the screenplay-ready myth to reveal a more authentic Hopper, a vibrant and complex woman whose career paralleled the meteoric trajectory of the postwar computer industry. Hopper made herself "one of the boys" in Howard Aiken's wartime Computation Laboratory at Harvard, then moved on to the Eckert and Mauchly Computer Corporation. Both rebellious and collaborative, she was influential in male-dominated military and business organizations at a time when women were encouraged to devote themselves to housework and childbearing. Hopper's greatest technical achievement was to create the tools that would allow humans to communicate with computers in terms other than ones and zeroes. This advance influenced all future programming and software design and laid the foundation for the development of user-friendly personal computers. Lemelson Center Studies in Invention and Innovation series}
}

@ARTICLE{influence_of_programming_techniques_on_the_design_of_computers,
  author={Hopper, G.M. and Mauchly, J.W.},
  journal={Proceedings of the IEEE}, 
  title={Influence of programming techniques on the design of computers}, 
  year={1997},
  volume={85},
  number={3},
  pages={470-474},
  keywords={Programming profession;Computer aided instruction;Design engineering;Costs;Application software;Hardware;Equations;Economics;High performance computing;Computer applications},
  doi={10.1109/5.558722}}

@inbook{Mahoney+2011+77+85,
url = {https://doi.org/10.4159/9780674274983-007},
title = {5 Software: The Self-Programming Machine},
booktitle = {Histories of Computing},
author = {Michael Sean Mahoney},
publisher = {Harvard University Press},
address = {Cambridge, MA and London, England},
pages = {77--85},
doi = {doi:10.4159/9780674274983-007},
isbn = {9780674274983},
year = {2011},
lastchecked = {2025-10-05}
}

@misc{computer_history_museum_collections,
	title = {Collections},
	url = {https://computerhistory.org/collections/},
	publisher = {Computer History Museum},
	language = {en},
	urldate = {2025-10-05},
	journal = {CHM},
}

@misc{smithsonian_computer_history_collection,
	title = {Computer {History} {Collection}},
	url = {https://americanhistory.si.edu/comphist/},
	urldate = {2025-10-05},
	publisher = {Smithsonian National Museum of American History},
}

@book{idea_factory,
	title={The Idea Factory: Bell Labs and the Great Age of American Innovation},
	publisher={Penguin Press},
	isbn = {9781594203282},
	author={Jon Gertner},
}

@book{phd_thesis_bohm_sestoft_2016,
title = "Calculatrices digitales: Du d{\'e}chiffrage de formules logico-math{\'e}matiques par la machine m{\^e}me dans la conception du programme",
author = "Corrado B{\"o}hm and Peter Sestoft",
note = "Translation into English of Corrado B{\"o}hm's ETH Z{\"u}rich PhD dissertation from the French original published 1954 in Bologna, Italy.",
year = "2016",
month = may,
day = "4",
language = "Fransk",
note = {Original title: DIGITAL COMPUTERS
On encoding logical-mathematical formulas
using the machine itself
during program conception}
}

@book{history_of_computing_in_the_twentieth_century_1980,
author = {Howlett, J. and Rota, Gian Carlo and Metropolis, Nicholas},
title = {History of Computing in the Twentieth Century},
year = {1980},
isbn = {0124916503},
publisher = {Academic Press, Inc.},
address = {USA}
}

@book{dealers_of_lightning_xerox_parc_hiltzik1999,
  author    = {Hiltzik, Michael A.},
  title     = {Dealers of Lightning: Xerox PARC and the Dawn of the Computer Age},
  publisher = {HarperBusiness},
  year      = {1999},
  isbn      = {9780887308918},
  address   = {New York}
}

@book{10.5555/1096897,
author = {Sammet, Jean E.},
title = {Programming Languages: History and Fundamentals},
year = {1969},
isbn = {0137299885},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}

@article{women_in_computing_history_2002,
author = {G\"{u}rer, Denise},
title = {Women in computing history},
year = {2002},
issue_date = {June 2002},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {2},
issn = {0097-8418},
url = {https://doi.org/10.1145/543812.543843},
doi = {10.1145/543812.543843},
abstract = {Exciting inventions, innovative technology, human interaction, and intriguing politics fill computing history. However, the recorded history is mainly composed of male achievements and involvements, even though women have played substantial roles. This situation is not unusual. Most science fields are notorious for excluding, undervaluing, or overlooking the accomplishments of their female scientists [1, 16, 17, 22]. As J.A.N. Lee points out, it is up to the historians and others to remedy this imbalance (see this issue [14]). Some steps have been taken towards this goal through publishing biographies on women in technology [2, 5, 6, 8, 12, 13, 18, 20, 21, 23, 24], also see this issue [7], and through honoring the pioneers with various awards such as the GHC'97 Pioneering Awards (Figure 1), the WITI Hall of Fame, and the AWC Lovelace Award. A few online sites contain biographies of women in technology, shown in Table 1 below. However, even with these resources, many women who have contributed significantly to computer science are still to be discovered.},
journal = {SIGCSE Bull.},
month = jun,
pages = {116–120},
numpages = {5}
}
