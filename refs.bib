% Wikipedia has been a useful collection of primary and secondary sources
% https://en.wikipedia.org/wiki/History_of_compiler_construction#cite_ref-8
% https://en.wikipedia.org/wiki/History_of_programming_languages
% https://en.wikipedia.org/wiki/Timeline_of_programming_languages
% author = {Haigh, Thomas and Ceruzzi, Paul E.},
@book{new-history-of-modern-computing,
  address      = {Cambridge [Massachusetts]},
  series       = {History of Computing},
  title        = {A New History of Modern Computing},
  isbn         = {9780262542906},
  abstract     = {"Bringing the history of modern computing fully up to date, from new applications to scientific computation to video games and the ubiquitous smartphone"},
  language     = {eng},
  publisher    = {The MIT Press},
  author       = {Haigh, Thomas},
  year         = {2021}
}
@misc{did_grace_hopper_create_the_first_compiler_2022,
  title        = {Did {Grace} {Hopper} {Create} the {First} {Compiler}? {Communications} of the {ACM}},
  shorttitle   = {Did {Grace} {Hopper} {Create} the {First} {Compiler}?},
  url          = {https://cacm.acm.org/blogcacm/did-grace-hopper-create-the-first-compiler/},
  language     = {en-US},
  urldate      = {2025-10-04},
  month        = dec,
  year         = {2022},
  author       = {Bruderer, Herbert}
}
@book{kernighan_unix:_2020,
  address      = {s. l.},
  title        = {{UNIX}: a history and a memoir},
  isbn         = {9781695978553},
  shorttitle   = {{UNIX}},
  language     = {eng},
  publisher    = {Kindle Direct Publishing},
  author       = {Kernighan, Brian W.},
  year         = {2020}
}
@inproceedings{bauer_software_1968,
  address      = {Garmisch, Germany},
  title        = {SOFTWARE ENGINEERING},
  booktitle    = {SOFTWARE ENGINEERING},
  url          = {https://www.scrummanager.com/files/nato1968e.pdf},
  publisher    = {NATO SCIENCE COMMITTEE},
  author       = {Bauer, Friedrick and Naur, Peter and Randell, Brian},
  month        = oct,
  year         = {1968}
}
@misc{numba_cuda,
  author       = {{NVIDIA Corporation}},
  title        = {Numba CUDA},
  shorttitle   = {Numba CUDA},
  year         = {2024},
  publisher    = {GitHub},
  howpublished = {\url{https://github.com/NVIDIA/numba-cuda/}},
  urldate      = {2025-10-04},
  note         = {The CUDA target for Numba}
}
@misc{jax-compiler,
  author       = {JAX Authors},
  howpublished = {\url{https://github.com/jax-ml/jax}},
  title        = {JAX: High performance array computing},
  year         = {2024}
}
@inproceedings{lam-numba,
  address      = {Austin Texas},
  title        = {Numba: a {LLVM}-based {Python} {JIT} compiler},
  isbn         = {9781450340052},
  shorttitle   = {Numba},
  url          = {https://dl.acm.org/doi/10.1145/2833157.2833162},
  doi          = {10.1145/2833157.2833162},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Proceedings of the {Second} {Workshop} on the {LLVM} {Compiler} {Infrastructure} in {HPC}},
  publisher    = {ACM},
  author       = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
  month        = nov,
  year         = {2015},
  pages        = {1--6}
}
@inproceedings{triton-tillet,
  address      = {Phoenix AZ USA},
  title        = {Triton: an intermediate language and compiler for tiled neural network computations},
  isbn         = {9781450367196},
  shorttitle   = {Triton},
  url          = {https://dl.acm.org/doi/10.1145/3315508.3329973},
  doi          = {10.1145/3315508.3329973},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Proceedings of the 3rd {ACM} {SIGPLAN} {International} {Workshop} on {Machine} {Learning} and {Programming} {Languages}},
  publisher    = {ACM},
  author       = {Tillet, Philippe and Kung, H. T. and Cox, David},
  month        = jun,
  year         = {2019},
  pages        = {10--19}
}
@inproceedings{lattner_adve_llvm_2004,
  author       = {Lattner, Chris and Adve, Vikram},
  title        = {LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation},
  year         = {2004},
  isbn         = {0769521029},
  publisher    = {IEEE Computer Society},
  address      = {USA},
  abstract     = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
  booktitle    = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
  pages        = {75},
  location     = {Palo Alto, California},
  series       = {CGO '04},
  url          = {https://llvm.org/pubs/2003-09-30-LifelongOptimizationTR.pdf}
}
@inproceedings{lattner_amini_mlir_og_paper_2021,
  author       = {Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},
  booktitle    = {2021 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  title        = {MLIR: Scaling Compiler Infrastructure for Domain Specific Computation},
  year         = {2021},
  url          = {https://ieeexplore.ieee.org/document/9370308},
  volume       = {},
  number       = {},
  pages        = {2--14},
  keywords     = {Program processors;Buildings;Semantics;Hardware;Software;Generators;Optimization},
  doi          = {10.1109/CGO51591.2021.9370308}
}
@inbook{hopl_backus_history_of_fortran,
  author       = {Backus, John},
  title        = {The history of Fortran I, II, and III},
  year         = {1978},
  isbn         = {0127450408},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://www.cs.toronto.edu/~bor/199y08/backus-fortran-copy.pdf},
  booktitle    = {History of Programming Languages},
  pages        = {25--74},
  numpages     = {50}
}
@inbook{hopl_keynote,
  author       = {Hopper, Grace},
  title        = {Keynote Address},
  year         = {1978},
  isbn         = {0127450408},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://dl.acm.org/doi/pdf/10.1145/800025.1198341},
  booktitle    = {History of Programming Languages},
  pages        = {25--74},
  numpages     = {50}
}
@inproceedings{rosen_altac_fortran_1961,
  author       = {Rosen, Saul},
  title        = {ALTAC, FORTRAN, and compatibility},
  year         = {1961},
  isbn         = {9781450373883},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/800029.808498},
  doi          = {10.1145/800029.808498},
  abstract     = {One of the major aims in the development of universal or common problem-oriented languages has been to permit a user to make the transition from one computer to another without the necessity of a complete reprogramming job.The ALTAC compiler, compatible with FORTRAN II, has been used to implement such a transition from the IBM 704 to the PHILCO 2000 at a number of installations. To the best of my knowledge this is the first time that a compiler has assumed the major burden of transition from a large scale computer of one manufacturer to an even larger scale computer of another manufacturer.},
  booktitle    = {Proceedings of the 1961 16th ACM National Meeting},
  pages        = {22.201--22.204},
  series       = {ACM '61}
}
@misc{noauthor_biography_nodate,
  title        = {Biography of {Grace} {Murray} {Hopper} {\textbar} {Office} of the {President}},
  url          = {https://president.yale.edu/biography-grace-murray-hopper},
  language     = {en},
  urldate      = {2025-10-04},
  year         = {2025}
}
@article{bellia_hierarchical_1981,
  title        = {Hierarchical development of programming languages},
  volume       = {18},
  copyright    = {http://www.springer.com/tdm},
  issn         = {0008-0624, 1126-5434},
  url          = {http://link.springer.com/10.1007/BF02576358},
  doi          = {10.1007/BF02576358},
  language     = {en},
  number       = {3},
  urldate      = {2025-10-04},
  journal      = {Calcolo},
  author       = {Bellia, M.},
  month        = sep,
  year         = {1981},
  pages        = {219--254}
}
@book{bentley_digitized:_2012,
  address      = {Oxford},
  title        = {Digitized: the science of computers and how it shapes our world},
  isbn         = {9780199693795},
  shorttitle   = {Digitized},
  abstract     = {In this book the author tells the story of computer science, explaining how and why computers were invented, how they work, looking at real-world examples of computers in use, and considering what will happen in the future. There's a hidden science that affects every part of your life. You are fluent in its terminology of email, WiFi, social networking, and encryption. You use its results when you make a telephone call, access the Internet, use any factory-produced product, or travel in any modern car. The discipline is so new that some prefer to call it a branch of engineering or mathematics. But it is so powerful and world-changing that you would be hard-pressed to find a single human being on the planet unaffected by its achievements. The science of computers enables the supply and creation of power, food, water, medicine, transport, money, communication, entertainment, and most goods in shops. It has transformed societies with the Internet, the digitization of information, mobile phone networks and GPS (Global Positioning System) technologies. Here, the author explores how this young discipline grew from its theoretical conception by pioneers such as Turing, through its growth spurts in the Internet, its difficult adolescent stage where the promises of Artificial Intelligence (AI) were never achieved and dot-com bubble burst, to its current stage as a (semi)mature field, now capable of remarkable achievements. Charting the successes and failures of computer science through the years, he discusses what innovations may change our world in the future},
  language     = {eng},
  publisher    = {Oxford university press},
  author       = {Bentley, Peter J.},
  year         = {2012}
}
@article{10.1145/99164.99179,
  author       = {Whitfield, D. and Soffa, M. L.},
  title        = {An approach to ordering optimizing transformations},
  year         = {1990},
  issue_date   = {Mar. 1990},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {25},
  number       = {3},
  issn         = {0362-1340},
  url          = {https://doi.org/10.1145/99164.99179},
  doi          = {10.1145/99164.99179},
  abstract     = {As an approach to deriving an application order of optimizing transformations, a framework is developed for examining the interactions of the transformations. The framework is based on an axiomatic specification technique and includes both pre-conditions and post conditions that must exist before and after applying optimizations. For a selected set of optimizations, the framework is used to determine those interactions among the optimizations that can create conditions and those that can destroy conditions for applying other optimizations. From these interactions, an application order is derived to obtain the potential benefits of the optimizations that can be applied to a program. In some cases, the ordering of a pair of optimizations is unambiguous in that one optimization can either create or destroy the conditions for the other. In the few cases where there is a cyclic interaction, the ordering is resolved based on the perceived importance of the two optimizations.},
  journal      = {SIGPLAN Not.},
  month        = feb,
  pages        = {137--146},
  numpages     = {10}
}
@article{bacon_compiler_1994,
  author       = {Bacon, David F. and Graham, Susan L. and Sharp, Oliver J.},
  title        = {Compiler transformations for high-performance computing},
  year         = {1994},
  issue_date   = {Dec. 1994},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {26},
  number       = {4},
  issn         = {0360-0300},
  url          = {https://doi.org/10.1145/197405.197406},
  doi          = {10.1145/197405.197406},
  abstract     = {In the last three decades a large number of compiler transformations for optimizing programs have been implemented. Most optimizations for uniprocessors reduce the number of instructions executed by the program using transformations based on the analysis of scalar quantities and data-flow techniques. In contrast, optimizations for high-performance superscalar, vector, and parallel processors maximize parallelism and memory locality with transformations that rely on tracking the properties of arrays using loop dependence analysis.This survey is a comprehensive overview of the important high-level program restructuring techniques for imperative languages, such as C and Fortran. Transformations for both sequential and various types of parallel architectures are covered in depth. We describe the purpose of each transformation, explain how to determine if it is legal, and give an example of its application.Programmers wishing to enhance the performance of their code can use this survey to improve their understanding of the optimizations that compilers can perform, or as a reference for techniques to be applied manually. Students can obtain an overview of optimizing compiler technology. Compiler writers can use this survey as a reference for most of the important optimizations developed to date, and as bibliographic reference for the details of each optimization. Readers are expected to be familiar with modern computer architecture and basic program compilation techniques.},
  journal      = {ACM Comput. Surv.},
  month        = dec,
  pages        = {345--420},
  numpages     = {76},
  keywords     = {vectorization, superscalar processors, parallelism, optimization, multiprocessors, locality, dependence analysis, compilation}
}
@misc{henry_comp.compilers:_nodate,
  title        = {Comp.compilers: {Re}: {History} and evolution of compilers},
  url          = {https://compilers.iecc.com/comparch/article/97-10-017},
  abstract     = {From comp.compilers newsgroup: Re: History and evolution of compilers},
  urldate      = {2025-10-04},
  author       = {Henry, Spencer},
  year         = {1997}
}
@misc{norman_grace_nodate,
  title        = {Grace {Hopper} and {Colleagues} {Introduce} {COBOL}},
  url          = {https://www.historyofinformation.com/detail.php?id=778},
  author       = {Norman, Jeremy},
  year         = {1959}
}
@book{laplante_encyclopedia_2017,
  address      = {BOCA RATON},
  edition      = {Second edition.},
  title        = {Encyclopedia of computer science and technology. {Volume} {II}, {Fuzzy}-{XML}},
  isbn         = {9781315115887},
  abstract     = {This book covers all aspects of computer science, engineering, and technology. It includes computer scientists, computer engineers computing professionals, managers, software professionals, and other technology professionals.},
  language     = {eng},
  publisher    = {CRC Press},
  author       = {Laplante, Phillip A.},
  year         = {2017},
  note         = {OCLC: 1032027866},
  keywords     = {Information technology Encyclopedias, Computer science Encyclopedias}
}
@article{landin_next_700_prog_langs_1966,
  title        = {The next 700 programming languages},
  volume       = {9},
  issn         = {0001-0782, 1557-7317},
  url          = {https://dl.acm.org/doi/10.1145/365230.365257},
  doi          = {10.1145/365230.365257},
  abstract     = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language.            The system is biased towards "expressions" rather than "statements." It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
  language     = {en},
  number       = {3},
  urldate      = {2025-10-04},
  journal      = {Communications of the ACM},
  author       = {Landin, P. J.},
  month        = mar,
  year         = {1966},
  pages        = {157--166}
}
@article{10.1145/321992.322001,
  author       = {Aho, A. V. and Johnson, S. C. and Ullman, J. D.},
  title        = {Code Generation for Expressions with Common Subexpressions},
  year         = {1977},
  issue_date   = {Jan. 1977},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {24},
  number       = {1},
  issn         = {0004-5411},
  url          = {https://doi.org/10.1145/321992.322001},
  doi          = {10.1145/321992.322001},
  abstract     = {This paper shows the problem of generating optimal code for expressions containing common subexpressions is computationally difficult, even for simple expressions and simple machines. Some heuristics for code generation are given and their worst-case behavior is analyzed. For one register machines, an optimal code generation algorithm is given whose time complexity is linear in the size of an expression and exponential only in the amount of sharing.},
  journal      = {J. ACM},
  month        = jan,
  pages        = {146--160},
  numpages     = {15}
}
@book{the_dragon_book_aho_ullman_sethi_1986,
  author       = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  title        = {Compilers: principles, techniques, and tools},
  year         = {1986},
  isbn         = {0201100886},
  publisher    = {Addison-Wesley Longman Publishing Co., Inc.},
  address      = {USA}
}
@book{the_dragon_book_aho_ullman_1977,
author = {Aho, Alfred V. and Ullman, Jeffrey D.},
title = {Principles of Compiler Design (Addison-Wesley series in computer science and information processing)},
year = {1977},
isbn = {0201000229},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA}
}
@article{10.1145/29873.29875,
  author       = {Allen, Randy and Kennedy, Ken},
  title        = {Automatic translation of FORTRAN programs to vector form},
  year         = {1987},
  issue_date   = {Oct. 1987},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {9},
  number       = {4},
  issn         = {0164-0925},
  url          = {https://doi.org/10.1145/29873.29875},
  doi          = {10.1145/29873.29875},
  abstract     = {The recent success of vector computers such as the Cray-1 and array processors such as those manufactured by Floating Point Systems has increased interest in making vector operations available to the FORTRAN programmer. The FORTRAN standards committee is currently considering a successor to FORTRAN 77, usually called FORTRAN 8x, that will permit the programmer to explicitly specify vector and array operations.Although FORTRAN 8x will make it convenient to specify explicit vector operations in new programs, it does little for existing code. In order to benefit from the power of vector hardware, existing programs will need to be rewritten in some language (presumably FORTRAN 8x) that permits the explicit specification of vector operations. One way to avoid a massive manual recoding effort is to provide a translator that discovers the parallelism implicit in a FORTRAN program and automatically rewrites that program in FORTRAN 8x.Such a translation from FORTRAN to FORTRAN 8x is not straightforward because FORTRAN DO loops are not always semantically equivalent to the corresponding FORTRAN 8x parallel operation. The semantic difference between these two constructs is precisely captured by the concept of dependence. A translation from FORTRAN to FORTRAN 8x preserves the semantics of the original program if it preserves the dependences in that program.The theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form. Dependence is defined and characterized in terms of the conditions that give rise to it; accurate tests to determine dependence are presented; and transformations that use dependence to uncover additional parallelism are discussed.},
  journal      = {ACM Trans. Program. Lang. Syst.},
  month        = oct,
  pages        = {491--542},
  numpages     = {52}
}
@book{10.5555/1097042,
  author       = {Cocke, John},
  title        = {Programming languages and their compilers: Preliminary notes},
  year         = {1969},
  isbn         = {B0007F4UOA},
  publisher    = {New York University},
  address      = {USA}
}
@techreport{allen_catalogue_1971,
  title        = {A {Catalogue} of {Optimizing} {Transformations}},
  url          = {https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf},
  institution  = {IBM J Watson Research Center},
  author       = {Allen, Francis and Cocke, John},
  year         = {1971}
}
@inproceedings{backus_fortran_1957,
  address      = {Los Angeles, California},
  title        = {The {FORTRAN} automatic coding system},
  copyright    = {https://www.acm.org/publications/policies/copyright\_policy\#Background},
  url          = {http://portal.acm.org/citation.cfm?doid=1455567.1455599},
  doi          = {10.1145/1455567.1455599},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Papers presented at the {February} 26-28, 1957, western joint computer conference: {Techniques} for reliability on - {IRE}-{AIEE}-{ACM} '57 ({Western})},
  publisher    = {ACM Press},
  author       = {Backus, J. W. and Stern, H. and Ziller, I. and Hughes, R. A. and Nutt, R. and Beeber, R. J. and Best, S. and Goldberg, R. and Haibt, L. M. and Herrick, H. L. and Nelson, R. A. and Sayre, D. and Sheridan, P. B.},
  year         = {1957},
  pages        = {188--198}
}
@book{the-first-computers-2002,
  author       = {Rojas, Raul and Hashagen, Ulf},
  title        = {The  First Computers: History and Architectures},
  year         = {2002},
  isbn         = {0262681374},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  abstract     = {From the Publisher:This history of computing focuses not on chronology (what came first and who deserves credit for it) but on the actual architectures of the first machines that made electronic computing a practical reality. The book covers computers built in the United States, Germany, England, and Japan. It makes clear that similar concepts were often pursued simultaneously and that the early researchers explored many architectures beyond the von Neumann architecture that eventually became canonical. The contributors include not only historians but also engineers and computer pioneers. An introductory chapter describes the elements of computer architecture and explains why "being first" is even less interesting for computers than for other areas of technology. The essays contain a remarkable amount of new material, even on well-known machines, and several describe reconstructions of the historic machines. These investigations are of more than simply historical interest, for architectures designed to solve specific problems in the past may suggest new approaches to similar problems in today's machines.}
}
@inproceedings{architecture-of-konrad-zuses-z4-computer-2021,
  author       = {Rojas, Raúl},
  booktitle    = {2021 7th IEEE History of Electrotechnology Conference (HISTELCON)},
  title        = {The Architecture of Konrad Zuse's Z4 Computer},
  year         = {2021},
  volume       = {},
  number       = {},
  url          = {https://ieeexplore.ieee.org/document/9787324},
  pages        = {43--47},
  keywords     = {Computers;Codes;Terminology;Instruction sets;Computer architecture;Programming;Telephone sets;Konrad Zuse;Versuchsmaschine 4;computer architecture},
  doi          = {10.1109/HISTELCON52394.2021.9787324}
}
@article{10.1145/361454.361515,
  author       = {Bauer, F. L. and W\"{o}ssner, H.},
  title        = {The "Plankalk\"{u}l" of Konrad Zuse: a forerunner of today's programming languages},
  year         = {1972},
  issue_date   = {July 1972},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {15},
  number       = {7},
  issn         = {0001-0782},
  url          = {https://doi.org/10.1145/361454.361515},
  doi          = {10.1145/361454.361515},
  abstract     = {Plankalk\"{u}l was an attempt by Konrad Zuse in the 1940's to devise a notational and conceptual system for writing what today is termed a program. Although this early approach to a programming language did not lead to practical use, the plan is described here because it contains features that are standard in today's programming languages. The investigation is of historical interest; also, it may provide insights that would lead to advancements in the state of the art. Using modern programming terminology, the Plankalk\"{u}l is presented to the extent it has been possible to reconstruct it from the published literature.},
  journal      = {Commun. ACM},
  month        = jul,
  pages        = {678--685},
  numpages     = {8},
  keywords     = {higher programming languages, history of programming, programming, theory of programming}
}
@inbook{konrad-zuses-z4-2000,
  author       = {Speiser, Ambros P.},
  title        = {Konrad Zuse's Z4: architecture, programming, and modifications at the ETH Zurich},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {263--276},
  numpages     = {14}
}
@inbook{notation_as_a_tool_of_thought_2007,
  author       = {Iverson, Kenneth E.},
  title        = {Notation as a tool of thought},
  year         = {2007},
  isbn         = {9781450310499},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/1283920.1283935},
  booktitle    = {ACM Turing Award Lectures},
  pages        = {1979}
}
@article{goldstine_annals_1980,
  title        = {\textit{{Annals} of the {History} of {Computing}} . {Bernard} {A}. {Galler}},
  volume       = {71},
  issn         = {0021-1753, 1545-6994},
  url          = {https://www.journals.uchicago.edu/doi/10.1086/352427},
  doi          = {10.1086/352427},
  language     = {en},
  number       = {1},
  urldate      = {2025-10-05},
  journal      = {Isis},
  author       = {Goldstine, Herman H.},
  month        = mar,
  year         = {1980},
  pages        = {160--160}
}
@inbook{nothing_new_since_von_neumann_2000,
  author       = {Ceruzzi, Paul},
  title        = {"Nothing new since von Neumann": a historian looks at computer architecture, 1945-1995},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {195--217},
  numpages     = {23}
}
@article{can_programming_be_liberated_from_the_von_neumann_style_1978,
  author       = {Backus, John},
  title        = {Can programming be liberated from the von Neumann style? a functional style and its algebra of programs},
  year         = {1978},
  issue_date   = {Aug. 1978},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {21},
  number       = {8},
  issn         = {0001-0782},
  url          = {https://doi.org/10.1145/359576.359579},
  doi          = {10.1145/359576.359579},
  abstract     = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor—the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs.An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose "unknowns" are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs.A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states—only one state transition occurs per major computation.},
  journal      = {Commun. ACM},
  month        = aug,
  pages        = {613--641},
  numpages     = {29},
  keywords     = {algebra of programs, applicative computing systems, applicative state transition systems, combining forms, functional forms, functional programming, metacomposition, models of computing systems, program correctness, program termination, program transformation, programming languages, von Neumann computers, von Neumann languages}
}
@book{grace_hopper_and_the_invention_of_the_information_age_2009,
  author       = {Beyer, Kurt W.},
  title        = {Grace Hopper and the Invention of the Information Age},
  year         = {2009},
  isbn         = {026201310X},
  publisher    = {The MIT Press},
  abstract     = {A Hollywood biopic about the life of computer pioneer Grace Murray Hopper (19061992) would go like this: a young professor abandons the ivy-covered walls of academia to serve her country in the Navy after Pearl Harbor and finds herself on the front lines of the computer revolution. She works hard to succeed in the all-male computer industry, is almost brought down by personal problems but survives them, and ends her career as a celebrated elder stateswoman of computing, a heroine to thousands, hailed as the inventor of computer programming. Throughout Hopper's later years, the popular media told this simplified version of her life story. In Grace Hopper and the Invention of the Information Age, Kurt Beyer goes beyond the screenplay-ready myth to reveal a more authentic Hopper, a vibrant and complex woman whose career paralleled the meteoric trajectory of the postwar computer industry. Hopper made herself "one of the boys" in Howard Aiken's wartime Computation Laboratory at Harvard, then moved on to the Eckert and Mauchly Computer Corporation. Both rebellious and collaborative, she was influential in male-dominated military and business organizations at a time when women were encouraged to devote themselves to housework and childbearing. Hopper's greatest technical achievement was to create the tools that would allow humans to communicate with computers in terms other than ones and zeroes. This advance influenced all future programming and software design and laid the foundation for the development of user-friendly personal computers. Lemelson Center Studies in Invention and Innovation series}
}
@article{influence_of_programming_techniques_on_the_design_of_computers,
  author       = {Hopper, G.M. and Mauchly, J.W.},
  journal      = {Proceedings of the IEEE},
  title        = {Influence of programming techniques on the design of computers},
  year         = {1997},
  volume       = {85},
  number       = {3},
  pages        = {470--474},
  keywords     = {Programming profession;Computer aided instruction;Design engineering;Costs;Application software;Hardware;Equations;Economics;High performance computing;Computer applications},
  doi          = {10.1109/5.558722}
}
@inbook{Mahoney+2011+77+85,
  url          = {https://doi.org/10.4159/9780674274983-007},
  title        = {5 Software: The Self-Programming Machine},
  booktitle    = {Histories of Computing},
  author       = {Michael Sean Mahoney},
  publisher    = {Harvard University Press},
  address      = {Cambridge, MA and London, England},
  pages        = {77--85},
  doi          = {doi:10.4159/9780674274983-007},
  isbn         = {9780674274983},
  year         = {2011},
  lastchecked  = {2025-10-05}
}
@misc{computer_history_museum_collections,
  title        = {Collections},
  url          = {https://computerhistory.org/collections/},
  publisher    = {Computer History Museum},
  language     = {en},
  urldate      = {2025-10-05},
  journal      = {CHM}
}
@misc{smithsonian_computer_history_collection,
  title        = {Computer {History} {Collection}},
  url          = {https://americanhistory.si.edu/comphist/},
  urldate      = {2025-10-05},
  publisher    = {Smithsonian National Museum of American History}
}
@book{idea_factory,
  title        = {The Idea Factory: Bell Labs and the Great Age of American Innovation},
  publisher    = {Penguin Press},
  isbn         = {9781594203282},
  author       = {Jon Gertner}
}
@book{phd_thesis_bohm_sestoft_2016,
  title        = {Calculatrices digitales: Du d{\'e}chiffrage de formules logico-math{\'e}matiques par la machine m{\^e}me dans la conception du programme},
  author       = {Corrado B{\"o}hm and Peter Sestoft},
  note         = {Translation into English of Corrado B{\"o}hm's ETH Z{\"u}rich PhD dissertation from the French original published 1954 in Bologna, Italy.},
  year         = {2016},
  month        = may,
  day          = {4},
  language     = {Fransk},
  note         = {Original title: DIGITAL COMPUTERS On encoding logical-mathematical formulas using the machine itself during program conception}
}
@book{history_of_computing_in_the_twentieth_century_1980,
  author       = {Howlett, J. and Rota, Gian Carlo and Metropolis, Nicholas},
  title        = {History of Computing in the Twentieth Century},
  year         = {1980},
  isbn         = {0124916503},
  publisher    = {Academic Press, Inc.},
  address      = {USA}
}
@book{dealers_of_lightning_xerox_parc_hiltzik1999,
  author       = {Hiltzik, Michael A.},
  title        = {Dealers of Lightning: Xerox PARC and the Dawn of the Computer Age},
  publisher    = {HarperBusiness},
  year         = {1999},
  isbn         = {9780887308918},
  address      = {New York}
}
@book{sammet_programming_languages_history_and_fundamentals_1969,
  author       = {Sammet, Jean E.},
  title        = {Programming Languages: History and Fundamentals},
  year         = {1969},
  isbn         = {0137299885},
  publisher    = {Prentice-Hall, Inc.},
  address      = {USA}
}
@article{women_in_computing_history_2002,
  author       = {G\"{u}rer, Denise},
  title        = {Women in computing history},
  year         = {2002},
  issue_date   = {June 2002},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {34},
  number       = {2},
  issn         = {0097-8418},
  url          = {https://doi.org/10.1145/543812.543843},
  doi          = {10.1145/543812.543843},
  abstract     = {Exciting inventions, innovative technology, human interaction, and intriguing politics fill computing history. However, the recorded history is mainly composed of male achievements and involvements, even though women have played substantial roles. This situation is not unusual. Most science fields are notorious for excluding, undervaluing, or overlooking the accomplishments of their female scientists [1, 16, 17, 22]. As J.A.N. Lee points out, it is up to the historians and others to remedy this imbalance (see this issue [14]). Some steps have been taken towards this goal through publishing biographies on women in technology [2, 5, 6, 8, 12, 13, 18, 20, 21, 23, 24], also see this issue [7], and through honoring the pioneers with various awards such as the GHC'97 Pioneering Awards (Figure 1), the WITI Hall of Fame, and the AWC Lovelace Award. A few online sites contain biographies of women in technology, shown in Table 1 below. However, even with these resources, many women who have contributed significantly to computer science are still to be discovered.},
  journal      = {SIGCSE Bull.},
  month        = jun,
  pages        = {116--120},
  numpages     = {5}
}
@misc{aho_oral_history_2022,
  author       = {Aho, Alfred V.},
  title        = {Oral History Interview with Alfred V. Aho},
  year         = {2022},
  month        = {June},
  day          = {13},
  howpublished = {Video interview},
  note         = {Interviewer: Hansen Hsu. Computer History Museum Oral History Collection. Catalogue number 102792705. Duration: 3:00:19. MOV format. Gift of Computer History Museum.},
  organization = {Computer History Museum},
  address      = {Chatham, New Jersey, USA},
  language     = {English},
  url          = {https://www.computerhistory.org/collections/catalog/102792704/}
}
@misc{aiken_oral_history_1973,
  author       = {Aiken, Howard},
  title        = {Oral History Interview with Howard Aiken},
  year         = {1973},
  month        = {February},
  day          = {26},
  howpublished = {Transcript},
  note         = {Interview conducted February 26-27, 1973, by Henry Tropp and I.~B. Cohen. Part of the Computer Oral History Collection, 1969-1973, 1977. Repository: Archives Center, National Museum of American History, Smithsonian Institution.},
  organization = {Smithsonian Institution},
  address      = {Washington, D.C., USA},
  url          = {https://mads.si.edu/mads/id/NMAH-AC0196_aike73027},
  language     = {English}
}
@book{aho-ullman-theory-of-parsing-translation-and-compiling-1972,
  author       = {Aho, Alfred V. and Ullman, Jeffrey D.},
  title        = {The theory of parsing, translation, and compiling},
  year         = {1972},
  isbn         = {0139145567},
  publisher    = {Prentice-Hall, Inc.},
  address      = {USA},
  abstract     = {From volume 1 Preface (See Front Matter for full Preface)This book is intended for a one or two semester course in compiling theory at the senior or graduate level. It is a theoretically oriented treatment of a practical subject. Our motivation for making it so is threefold.(1) In an area as rapidly changing as Computer Science, sound pedagogy demands that courses emphasize ideas, rather than implementation details. It is our hope that the algorithms and concepts presented in this book will survive the next generation of computers and programming languages, and that at least some of them will be applicable to fields other than compiler writing.(2) Compiler writing has progressed to the point where many portions of a compiler can be isolated and subjected to design optimization. It is important that appropriate mathematical tools be available to the person attempting this optimization.(3) Some of the most useful and most efficient compiler algorithms, e.g. LR(k) parsing, require a good deal of mathematical background for full understanding. We expect, therefore, that a good theoretical background will become essential for the compiler designer.While we have not omitted difficult theorems that are relevant to compiling, we have tried to make the book as readable as possible. Numerous examples are given, each based on a small grammar, rather than on the large grammars encountered in practice. It is hoped that these examples are sufficient to illustrate the basic ideas, even in cases where the theoretical developments are difficult to follow in isolation.From volume 2 Preface (See Front Matter for full Preface)Compiler design is one of the first major areas of systems programming for which a strong theoretical foundation is becoming available. Volume I of The Theory of Parsing, Translation, and Compiling developed the relevant parts of mathematics and language theory for this foundation and developed the principal methods of fast syntactic analysis. Volume II is a continuation of Volume I, but except for Chapters 7 and 8 it is oriented towards the nonsyntactic aspects of compiler design.The treatment of the material in Volume II is much the same as in Volume I, although proofs have become a little more sketchy. We have tried to make the discussion as readable as possible by providing numerous examples, each illustrating one or two concepts.Since the text emphasizes concepts rather than language or machine details, a programming laboratory should accompany a course based on this book, so that a student can develop some facility in applying the concepts discussed to practical problems. The programming exercises appearing at the ends of sections can be used as recommended projects in such a laboratory. Part of the laboratory course should discuss the code to be generated for such programming language constructs as recursion, parameter passing, subroutine linkages, array references, loops, and so forth.}
}
@online{aho_turing_award_2020,
  author       = {Haigh, Thomas and ACM Staff},
  title        = {Alfred Vaino Aho --- {A.M. Turing Award Laureate 2020}},
  date         = {2020},
  organization = {Association for Computing Machinery},
  url          = {https://amturing.acm.org/award_winners/aho_1046358.cfm},
  note         = {Citation: ``For fundamental algorithms and theory underlying programming language implementation and for synthesizing these results and those of others in their highly influential books, which educated generations of computer scientists.''},
  language     = {English}
}
@book{history_of_modern_computing_2003_ceruzzi,
  author       = {Ceruzzi, Paul E.},
  title        = {A History of Modern Computing},
  year         = {2003},
  isbn         = {0262532034},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  edition      = {2}
}
% Section 11: LLVM
@book{brown_wilson_lattner_aosa_vol1_2011,
  title        = {The Architecture of Open Source Applications, Volume I: Twenty-four designers explain how their software works},
  editor       = {Brown, Amy and Wilson, Greg},
  year         = {2011},
  publisher    = {aosabook.org},
  address      = {Online},
  isbn         = {978-1-257-63804-3},
  url          = {https://aosabook.org/en/index.html},
  note         = {Available online at \url{https://aosabook.org/en/}}
}
@phdthesis{Lattner2002-zt,
  abstract     = {Abstract Modern programming languages and software engineering principles are causing increasing problems for compiler systems. Traditional approaches, which use a simple compile-link-execute model, are unable to provide adequate application performance ...},
  added-at     = {2015-07-14T13:30:28.000+0200},
  author       = {Lattner, Chris Arthur},
  biburl       = {https://www.bibsonomy.org/bibtex/2fe6a01795d434156c888668106070fa0/christophv},
  interhash    = {db8e714e9b13e69ce73c214398af5218},
  intrahash    = {fe6a01795d434156c888668106070fa0},
  keywords     = {Expose LLVM},
  publisher    = {llvm.org},
  school       = {University of Illinois at Urbana-Champaign},
  timestamp    = {2016-01-04T14:22:08.000+0100},
  title        = {{LLVM}: An infrastructure for multi-stage optimization},
  year         = {2002}
}
@online{carruth_understanding_compiler_2015,
  author       = {Chandler Carruth},
  title        = {Understanding Compiler Optimization — Opening Keynote, Meeting C++ 2015},
  date         = {2015-12-19},
  organization = {Meeting C++ / YouTube},
  url          = {https://www.youtube.com/watch?v=FnGCDLhaxKU},
  note         = {YouTube video of opening keynote on compiler optimization}
}
@misc{carruth_modernizing_compiler_2023,
  author       = {Chandler Carruth},
  title        = {Modernizing Compiler Design for Carbon Toolchain},
  year         = {2023},
  howpublished = {YouTube video, CppNow 2023 Conference},
  organization = {CppNow},
  note         = {Premiered Aug 17, 2023. Discusses modern compiler architecture and the Carbon language toolchain.},
  url          = {https://www.youtube.com/watch?v=ZI198eFghJk},
  slides       = {https://github.com/boostcon},
  keywords     = {compiler design, C++, Carbon, LLVM}
}
@online{spickett_flang_levels_up_2025,
  author       = {David Spickett},
  title        = {LLVM Fortran Levels Up: Goodbye \texttt{flang-new}, Hello \texttt{flang}!},
  date         = {2025-03-11},
  organization = {LLVM Project Blog},
  url          = {https://blog.llvm.org/posts/2025-03-11-flang-new/},
  keywords     = {Flang, Fortran, MLIR, LLVM},
  note         = {33 minute read. Blog post on the LLVM Project site discussing the renaming of Flang and its development history.}
}
@online{godbolt_happy_birthday_ce_2022,
  author       = {Matt Godbolt},
  title        = {Happy 10th Birthday Compiler Explorer!},
  date         = {2022-06-22},
  organization = {Matt Godbolt's Blog},
  url          = {https://xania.org/202206/happy-birthday-ce},
  note         = {Blog post celebrating the 10th anniversary of Compiler Explorer.},
  keywords     = {Compiler Explorer, blog, history}
}
@online{chipletter_history_of_c_compilers_part1,
  author       = {Babbage},
  title        = {A History of C Compilers — Part 1: Performance, Portability and Freedom},
  date         = {2024-05-05},
  organization = {The Chip Letter (Substack)},
  url          = {https://thechipletter.substack.com/p/a-history-of-c-compilers-part-1-performance},
  note         = {Whistle-stop tour of the evolution of C compilers, emphasizing performance, portability, and freedom.},
  keywords     = {C compilers, history, performance, portability}
}
@article{annals_of_the_computation_laboratory_of_harvard_university_1946,
  author       = {Miller, J. C. P.},
  title        = {The Annals of the Computation Laboratory of Harvard University --- 1. Vol. I. A Manual of Operation for the Automatic Sequence Controlled Calculator. Pp. xvi + 561 + 17 plates. 1946. 2. Vol. II. Tables of the Modified Hankel Functions of Order One-third and of their Derivatives. Pp. xxxvi + 235. 1945. 3. Vol. III. Tables of the Bessel Functions of the First Kind of Orders Zero and One. Pp. xxxviii + [652]. 1947. 4. Vol. IV. Tables of the Bessel Functions of the First Kind of Orders Two and Three. Pp. x + [652]. 1947.},
  journal      = {The Mathematical Gazette},
  year         = {1947},
  volume       = {31},
  number       = {295},
  pages        = {178--181},
  doi          = {10.2307/3610522},
  url          = {https://chimera.roma1.infn.it/SP/COMMON/MarkI_operMan_1946.pdf}
}
@online{backus_oral_history_2006,
  author       = {John W. Backus},
  title        = {John Backus Oral History Transcript},
  date         = {2006-09-05},
  organization = {Computer History Museum},
  location     = {Ashland, Oregon, USA},
  note         = {Interviewed by Grady Booch, videography by Gardner Hendrie. 42 pages. Catalogue number 102657970. Acquisition number X3715.2007.},
  url          = {https://www.computerhistory.org/collections/catalog/102657970/},
  keywords     = {FORTRAN, IBM 704, programming languages, software history, oral history},
  language     = {English}
}
@online{backus_ibm_history,
  author       = {IBM Corporation},
  title        = {John Backus — The father of Fortran changed programming forever},
  date         = {2025-10-09},
  organization = {IBM},
  url          = {https://www.ibm.com/history/john-backus},
  note         = {Biography of John W. Backus, covering his work at IBM, development of FORTRAN, and contributions to programming languages.},
  language     = {English}
}
@techreport{IBM_1954_Speedcoding,
  author       = {{International Business Machines Corporation}},
  title        = {IBM Speedcoding System for the Type 701 Electronic Data Processing Machines},
  year         = {1954},
  note         = {[1953-09-10]},
  institution  = {International Business Machines Corporation},
  address      = {New York, USA},
  type         = {Technical Manual},
  number       = {Form 24-6059-0 (5-54:2M-W)},
  url          = {https://archive.computerhistory.org/resources/access/text/2018/02/102678975-05-01-acc.pdf},
  howpublished = {Archived PDF at Computer History Museum},
  urldate      = {2022-07-04}
}
@incollection{Hamming_Feigenbaum_1971_IBM7094,
  author       = {Richard W. Hamming and Edward A. Feigenbaum},
  title        = {The {IBM} 701--7094 II Sequence: A Family by Evolution},
  booktitle    = {Computer Structures: Readings and Examples},
  editor       = {C. Gordon Bell and Allen Newell},
  year         = {1971},
  publisher    = {McGraw-Hill Book Company},
  address      = {New York, USA},
  series       = {McGraw-Hill Computer Science Series},
  url          = {https://tcm.computerhistory.org/ComputerTimeline/Chap41_ibm7094_CS1.pdf},
  note         = {Reprinted by the Computer History Museum, Section 1 of \emph{Computer Structures: Readings and Examples}}
}
@techreport{IBM_1954_FORTRAN_Specifications,
  title        = {Preliminary Report: Specifications for the IBM Mathematical FORmula TRANslating System (FORTRAN)},
  author       = {{International Business Machines Corporation (IBM)}},
  year         = {1954},
  month        = nov,
  institution  = {International Business Machines Corporation},
  type         = {Technical Report},
  number       = {102679231},
  note         = {Gift of J.A.N. Lee. Fortran Archive, Computer History Museum. Acquisition number X2677.2004},
  url          = {https://archive.computerhistory.org/resources/text/Fortran/102679231.05.01.acc.pdf},
  address      = {New York, USA},
  language     = {English},
  howpublished = {Computer History Museum}
}
@online{McJones_2025_FORTRAN_History,
  author       = {Paul McJones},
  title        = {History of FORTRAN and FORTRAN II},
  year         = {2025},
  month        = jul,
  editor       = {Paul McJones},
  organization = {Computer History Museum, Software Preservation Group},
  url          = {https://mcjones.org/dustydecks},
  note         = {Last modified 2025-07-21. Project to preserve source code, design documents, and other materials concerning the original IBM 704 FORTRAN/FORTRAN II compiler.},
  howpublished = {\url{https://www.softwarepreservation.org/projects/FORTRAN/}},
  email        = {paul@mcjones.org},
  language     = {English}
}
@incollection{Backus_1980_Programming_in_America_in_1950s,
  author       = {John W. Backus},
  title        = {Programming in America in the 1950s: Some Personal Impressions},
  booktitle    = {A History of Computing in the Twentieth Century: A Collection of Essays},
  editor       = {N. Metropolis and J. Howlett and Gian-Carlo Rota},
  publisher    = {Academic Press},
  address      = {New York, USA},
  year         = {1980},
  pages        = {125--135},
  url          = {https://www.softwarepreservation.org/projects/FORTRAN/paper/Backus-ProgrammingInAmerica-1976.pdf},
  note         = {Originally written in 1976. Reprinted in \textit{A History of Computing in the Twentieth Century}.},
  language     = {English}
}
@techreport{Knuth_TrabbPardo_1976_Early_Development,
  author       = {Donald E. Knuth and Luis Trabb Pardo},
  title        = {The Early Development of Programming Languages},
  institution  = {Department of Computer Science, Stanford University},
  year         = {1976},
  month        = jul,
  type         = {Technical Report},
  number       = {ADA032123},
  address      = {Stanford, CA, USA},
  pages        = {112},
  note         = {Commissioned by the \textit{Encyclopedia of Computer Science and Technology}, ed. Jack Belzer, Albert G. Holzman, and Allen Kent. Approved for public release.},
  url          = {https://apps.dtic.mil/sti/citations/ADA032123},
  url2         = {https://bitsavers.org/pdf/stanford/cs_techReports/STAN-CS-76-562_EarlyDevelPgmgLang_Aug76.pdf},
  abstract     = {This paper surveys the evolution of high-level programming languages during the first decade of computer programming activity, including contributions from Zuse, Goldstine and von Neumann, Curry, Mauchly, Rutishauser, Böhm, Glennie, Hopper, Backus, Brooker, and others.},
  keywords     = {programming languages, compilers, high-level languages, FORTRAN, early computing, computer history},
  language     = {English}
}
@inproceedings{Backus_Herrick_1954_Speedcoding,
  author       = {John W. Backus and Harlan Herrick},
  title        = {IBM 701 Speedcoding and Other Automatic Programming Systems},
  booktitle    = {Proceedings of the Symposium on Automatic Programming for Digital Computers},
  organization = {Office of Naval Research, Department of the Navy},
  address      = {Washington, D.C., USA},
  year         = {1954},
  month        = may,
  pages        = {106--113},
  note         = {Navy Mathematical Computing Advisory Panel, 13--14 May 1954. Computer History Museum Lot X2677.2004, Box 3 of 6. Donated by J.A.N. Lee.},
  url          = {https://www.softwarepreservation.org/projects/FORTRAN/paper/Backus%20and%20Herrick%20-%20Speedcoding%20-%20ONR%201954.pdf},
  howpublished = {Archived by the Computer History Museum, curated by Paul McJones (2005-12-30).},
  language     = {English}
}
@misc{Hopper_1980_Oral_History,
  author       = {Grace Murray Hopper},
  title        = {Grace Hopper Oral History},
  year         = {1980},
  month        = dec,
  howpublished = {Transcript, Computer History Museum Oral History Collection},
  editor       = {Angeline Pantages},
  interviewer  = {Angeline Pantages},
  institution  = {Computer History Museum},
  address      = {Naval Data Automation Command, Maryland, USA},
  url          = {https://www.computerhistory.org/collections/catalog/102702026/},
  note         = {Catalogue number 102702026. Gift of Angela Pantages Doyne. Acquisition number X5142.2009.},
  language     = {English},
  abstract     = {In this 1980 interview, Grace Murray Hopper discusses her entry into computing, work with Howard Aiken on the Harvard Mark series, collaboration with John Mauchly and the Eckert-Mauchly Computer Corporation, and the development of the A-0 and Flow-Matic compilers leading to COBOL.},
  keywords     = {Grace Hopper, COBOL, Flow-Matic, FORTRAN, UNIVAC, Mark I, Eckert-Mauchly, early programming languages, oral history}
}
@inbook{howard_aiken_and_the_dawn_of_the_computer_age_2000,
  author       = {Cohen, I. Bernard},
  title        = {Howard Aiken and the dawn of the computer age},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {107--120},
  numpages     = {14}
}
@book{10.5555/583656,
  author       = {Aspray, William},
  title        = {Proceedings of a Symposium on Large Scale Digital Calculating Machinery 1948},
  year         = {1985},
  isbn         = {0262081520},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  abstract     = {From the Publisher:In January 1947, the Navy Department Bureau of Ordnance and Harvard University jointly sponsored a symposium at the Harvard Computation Laboratory on large-scale digital calculating machinery. It provided one of the first and most important early forums for discussion of the problems and approaches in the design, construction, operation, and application of computers. Coming before the establishment of professional journals, societies, or regular meetings in computer science, the proceedings of the symposium offer the best picture of computing technology in the early years that we have available. Included are papers by Howard Aiken, Samuel Caldwell, Jay Forrester, Herman Goldstine, John Mauchly, George Stibitz, and over twenty others.   Proceedings of a Symposium on Large-Scale Digital Calculating Machinery was published in 1948 by Harvard University Press. It is Volume VIII in the Charles Babbage Institute Reprint Series.},
  url          = {http://www.bitsavers.org/pdf/harvard/Proceedings_of_a_Second_Symposium_on_Large-Scale_Digital_Calculating_Machinery_Sep49.pdf}
}
@inproceedings{education_of_a_computer_1952_hopper,
  author       = {Hopper, Grace Murray},
  title        = {The education of a computer},
  year         = {1952},
  isbn         = {9781450373623},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/609784.609818},
  doi          = {10.1145/609784.609818},
  abstract     = {While the materialization is new, the idea of mechanizing mathematical thinking is not new. Its lineage starts with the abacus and descends through Pascal,Leibnitz, and Babbage. More immediately, the ideas here presented originate from Professor Howard H. Aiken of Harvard University, Dr.  John W. Mauchly of Eckert-Mauchly and Dr. M. V. Wilkes of the University of Cambridge. From Professor Aiken came, in 1946, the idea of a library of routines described in the Mark I manual, and the concepts embodied in the Mark III coding machine, from Dr. Mauchly, the basic principles of the "short-order code" and suggestions, criticisms, and untiring patience in listening to these present attempts; from Dr. Wilkes, the greatest help of all, a book on the subject. For those of their ideas which are included herein, I most earnestly express my debt and my appreciation.},
  booktitle    = {Proceedings of the 1952 ACM National Meeting (Pittsburgh)},
  pages        = {243--249},
  numpages     = {7},
  location     = {Pittsburgh, Pennsylvania},
  series       = {ACM '52}
}
@inproceedings{ridgway_compiling_routines_1952,
  author       = {Ridgway, Richard K.},
  title        = {Compiling routines},
  year         = {1952},
  isbn         = {9781450379250},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/800259.808980},
  doi          = {10.1145/800259.808980},
  abstract     = {Since the advent of automatic computation, programmers have devoted much of their time and energy to looking up, adjusting, and transcribing material previously programmed. This has proved a most inefficient method of program preparation. Within the experience of the programming staff of Eckert-Mauchly, such manipulation and transcription has been a major source of programming errors.In an attempt to lighten the load on the programmer, and to eliminate such errors, members of the Computational Analysis Laboratory have devised programs called "compilers". A compiler looks up subroutines, adjusts them, and assembles them, as a complete program. The fruitfulness of the compiler method of program preparation is now clearly evident. One immediate result is a considerable saving in time in the preparation of programs for the solution of mathematical problems. At present, compilers are capable of handling scientific problems, and in the near future, they will be available to treat commercial problems.},
  booktitle    = {Proceedings of the 1952 ACM National Meeting (Toronto)},
  pages        = {1-5},
  numpages     = {5},
  location     = {Toronto, Ontario, Canada},
  series       = {ACM '52}
}
@misc{pentagon_hopper_univac_workshop_1953,
  title        = {Second Workshop on {UNIVAC} Automatic Programming (Exhibit F)},
  year         = {1953},
  month        = dec,
  day          = {1},
  location     = {The Pentagon},
  institution  = {Directorate of Management Analysis, Deputy Chief of Staff, Comptroller, Headquarters, U.S. Air Force, and Remington Rand, Inc.},
  howpublished = {Archival material, Box 5, Folder 1, Grace Murray Hopper Collection, Series 6: Compiling Routines},
  url          = {https://americanhistory.si.edu/fr/collections/archival-item/sova-nmah-ac-0324-ref334},
  note         = {Record ID: ebl-1562729477047-1562729477111-2. GUID: https://n2t.net/ark:/65665/ep840713f12-e928-4c4a-a0fe-7010232d7b9b. Usage conditions apply.},
  author       = {{Directorate of Management Analysis, Deputy Chief of Staff, Comptroller, Headquarters, U.S. Air Force, and Remington Rand, Inc.}},
  collection   = {Grace Murray Hopper Collection},
}
@inproceedings{hopper_interlude_1956,
	address = {Washington, {D.C.}},
	title = {The Interlude 1954-1956},
	language = {English},
	booktitle = {Symposium on Advanced Programming Methods for Digital Computers: Washington, {D.C.}, June 28, 29, 1956},
	publisher = {Office of Naval Research, Dept. of the Navy},
	author = {Hopper, Grace M.},
	year = {1956},
	pages = {1--2}
}
@techreport{ash_etal_1957_math-matic_manual,
  title        = {Preliminary Manual for MATH-MATIC and ARITH-MATIC Systems for Algebraic Translation and Compilation for UNIVAC I and II},
  author       = {Ash, R. and Broadwin, E. and Della Valle, V. and Greene, M. and Jenny, A. and Katz, C. and Yu, L.},
  institution  = {Automatic Programming Development, Remington Rand UNIVAC},
  address      = {Philadelphia, Pennsylvania},
  year         = {1957},
  month        = apr,
  day          = {19},
  url          = {https://archive.computerhistory.org/resources/access/text/2016/06/102724614-05-01-acc.pdf},
  note         = {Prepared by the Automatic Programming Development group at Remington Rand UNIVAC.},
  howpublished = {Technical report},
}
@inbook{sammet_early_history_of_cobol_1978,
  author = {Sammet, Jean E.},
  title = {The early history of COBOL},
  year = {1978},
  isbn = {0127450408},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800025.1198367},
  booktitle = {History of Programming Languages},
  pages = {199-243},
  numpages = {45}
}
@misc{hopper_1955_preliminary_definitions_data_processing_compiler,
  author       = {Hopper, Grace Murray},
  title        = {Preliminary Definitions: Data-Processing Compiler},
  year         = {1955},
  month        = jan,
  day          = {31},
  howpublished = {Archival material, Box 4, Folder 12, Grace Murray Hopper Collection, Series 5: Eckert-Mauchly Corporation},
  institution  = {Smithsonian National Museum of American History},
  note         = {Record ID: ebl-1562729477047-1562729477108-3. GUID: https://n2t.net/ark:/65665/ep8441f23a6-5a7e-40dd-a2c4-d7060145f911. Usage conditions apply.},
  url          = {https://americanhistory.si.edu/collections/archival-item/sova-nmah-ac-0324-ref311},
}
@article{hawes_woods_1971_optimized_code_generation,
author = {Woods, C. Geoffrey and Hawes, Mary K.},
title = {Optimized code generation from extended-entry decision tables},
year = {1971},
issue_date = {September 1971},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/953368.953378},
doi = {10.1145/953368.953378},
abstract = {Optimized algorithms have been developed for the processing of extendad-entry decision tables. and for the direct conversion of extended-entry tables to code without translation of the extended-entry decision tables to limited-entry tables. One of the algorithms is described and discussed in this paper. Examples are given to illustrate why direct code conversion is better, and why it is better. Although the amount of improvement will very from table to table. and indication of the savings is included.},
journal = {SIGPLAN Not.},
month = sep,
pages = {74–80},
numpages = {7}
}
@manual{sperryrand_1959_flowmatic,
  title        = {{FLOW-MATIC} Programming System, U1518 Rev. 1},
  author       = {{Sperry Rand Corporation}},
  year         = {1959},
  note         = {© 1958, 1959. UNIVAC Division.},
  organization = {Sperry Rand Corporation},
  address      = {Philadelphia, Pennsylvania},
  url          = {https://bitsavers.trailing-edge.com/pdf/univac/flow-matic/U1518_FLOW-MATIC_Programming_System_1958.pdf},
}
@article{perlis_samelson_1958_preliminary_report_ial,
author = {Perlis, A. J. and Samelson, K.},
title = {Preliminary report: international algebraic language},
year = {1958},
issue_date = {Dec. 1958},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/377924.594925},
doi = {10.1145/377924.594925},
journal = {Commun. ACM},
month = dec,
pages = {8–22},
numpages = {15}
}
@manual{burroughs1963bac220,
  title        = {BAC-220: Burroughs Algebraic Compiler (Revised Edition)},
  author       = {{Burroughs Corporation}},
  year         = {1963},
  month        = mar,
  institution  = {Equipment \& Systems Marketing Division, Burroughs Corporation},
  address      = {Detroit 32, Michigan},
  note         = {Document No. 220-21017},
  url          = {https://bitsavers.org/pdf/burroughs/Electrodata/220/220-21017_B220_BALGOL_196303.pdf}
}
@inproceedings{backus_ial_1959,
  author    = {Backus, John Warner},
  title     = {The Syntax and Semantics of the Proposed International Algebraic Language of the Zurich {ACM}-{GAMM} Conference},
  booktitle = {Proceedings of the First International Conference on Information Processing},
  year      = {1959},
  address   = {Paris, France},
  publisher = {R. Oldenbourg, Munich and Butterworth, London},
  pages     = {125--132},
  organization = {UNESCO},
  url       = {https://www.softwarepreservation.org/projects/ALGOL/paper/Backus-Syntax_and_Semantics_of_Proposed_IAL.pdf}
}
@article{naur_backus_algol_1960,
author = {Backus, J. W. and Bauer, F. L. and Green, J. and Katz, C. and McCarthy, J. and Perlis, A. J. and Rutishauser, H. and Samelson, K. and Vauquois, B. and Wegstein, J. H. and van Wijngaarden, A. and Woodger, M. and Naur, Peter},
title = {Report on the algorithmic language ALGOL 60},
year = {1960},
issue_date = {May 1960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {5},
issn = {0001-0782},
url = {https://doi.org/10.1145/367236.367262},
doi = {10.1145/367236.367262},
journal = {Commun. ACM},
month = may,
pages = {299–311},
numpages = {13}
}
@article{naur_algol_bulletin_questionaire_1962,
  title={ALGOL bulletin no. 14.1, The Questionnaire},
  author={Naur, Peter},
  journal={ACM SIGPLAN Notices},
  volume={14},
  number={1},
  year={1962},
  publisher={ACM New York, NY, USA}
}
@article{naur_revised_report_algol_1962,
author = {Backus, J. W. and Bauer, F. L. and Green, J. and Katz, C. and McCarthy, J. and Perlis, A. J. and Rutishauser, H. and Samelson, K. and Vauquois, B. and Wegstein, J. H. and van Wijngaarden, A. and Woodger, M. and Naur, P.},
title = {Revised report on the algorithmic language ALGOL 60},
year = {1963},
issue_date = {Jan. 1963},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/366193.366201},
doi = {10.1145/366193.366201},
journal = {Commun. ACM},
month = jan,
pages = {1–17},
numpages = {17}
}
@book{revised_report_on_the_algorithmic_language_algol_68_1976,
  editor       = {A. van Wijngaarden and B. J. Mailloux and J. E. L. Peck and C. H. A. Koster
                  and M. Sintzoff and C. H. Lindsey and L. G. L. T. Meertens and R. G. Fisker},
  title        = {Revised Report on the Algorithmic Language {ALGOL} 68},
  publisher    = {Springer-Verlag},
  year         = {1976},
  isbn         = {978-0-387-07592-1},
  oclc         = {1991170},
  url          = {https://web.archive.org/web/20190419223929/http://web.eah-jena.de/~kleine/history/languages/algol68-revisedreport.pdf},
  note         = {Retrieved October 14, 2025}
}
@book{dijkstra_primer_of_algol_programming_1962,
author = {Dijkstra, E. W.},
title = {Primer of Algol 60 Programming},
year = {1962},
isbn = {0122162501},
publisher = {Academic Press, Inc.},
address = {USA}
}
@article{draft_report_algol_1968,
author = {Van Wijngaarden, A. and Mailloux, B. J. and Peck, J. and Koster, C. H. A.},
title = {Draft Report on the Algorithmic Language ALGOL 68},
year = {1968},
issue_date = {Mar. 1968},
publisher = {Computer History Museum},
address = {Mountain View, CA, USA},
number = {Sup 26},
issn = {0084-6198},
journal = {ALGOL Bull.},
month = mar,
pages = {1–84},
numpages = {84}
}
@article{Knuth1964ManOrBoy,
  author    = {Donald E. Knuth},
  title     = {Man or Boy?},
  journal   = {ALGOL Bulletin},
  number    = {17},
  pages     = {7},
  year      = {1964},
  month     = {July},
  note      = {AB17.2.4 Donald Knuth: Man or Boy?, page 7. See also: \emph{Algol Bulletin}. \emph{Computing at Chilton: 1961--2000}. Retrieved December 25, 2009},
  url       = {https://archive.computerhistory.org/resources/text/algol/algol_bulletin/A17/P24.HTM},
  publisher = {IFIP Working Group 2.1 on ALGOL}
}
@misc{Cameron2002PassByName,
  author       = {Robert D. Cameron},
  title        = {Pass-By-Name Parameter Passing},
  howpublished = {CMPT 383 Lecture Notes},
  year         = {2002},
  month        = {March 6},
  url          = {https://www.cs.sfu.ca/~cameron/Teaching/383/PassByName.html},
  note         = {Accessed <add access date here>}
}
@article{dijkstra_defense_of_algol_60_1961,
author = {Dijkstra, E. W.},
title = {Letter to the editor: defense of ALGOL 60},
year = {1961},
issue_date = {Nov. 1961},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {11},
issn = {0001-0782},
url = {https://doi.org/10.1145/366813.366844},
doi = {10.1145/366813.366844},
journal = {Commun. ACM},
month = nov,
pages = {502-503},
numpages = {2}
}
@article{10.1145/155360.155365,
author = {Lindsey, C. H.},
title = {A history of ALGOL 68},
year = {1993},
issue_date = {March 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {28},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/155360.155365},
doi = {10.1145/155360.155365},
abstract = {ALGOL 68 is a language with a lot of “history”. The reader will hear of discord, resignations, unreadable documents, a minority report, and all manner of politicking. But although ALGOL 68 was produced by a committee (and an unruly one at that), the language itself is no camel. Indeed, the rigorous application of the principle of “orthogonality” makes it one of the cleanest languages around, as I hope to show. Moreover, when the language came to be revised, the atmosphere was quite different enabling a much more robust and readable defining document to be produced in a spirit of true cooperation. There are some lessons here for future language design efforts, but I am not optimistic that they have been learned.},
journal = {SIGPLAN Not.},
month = mar,
pages = {97–132},
numpages = {36}
}
@inproceedings{a_history_of_algol_68_1993,
author = {Lindsey, C. H.},
title = {A history of ALGOL 68},
year = {1993},
isbn = {0897915704},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/154766.155365},
doi = {10.1145/154766.155365},
abstract = {ALGOL 68 is a language with a lot of “history”. The reader will hear of discord, resignations, unreadable documents, a minority report, and all manner of politicking. But although ALGOL 68 was produced by a committee (and an unruly one at that), the language itself is no camel. Indeed, the rigorous application of the principle of “orthogonality” makes it one of the cleanest languages around, as I hope to show. Moreover, when the language came to be revised, the atmosphere was quite different enabling a much more robust and readable defining document to be produced in a spirit of true cooperation. There are some lessons here for future language design efforts, but I am not optimistic that they have been learned.},
booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
pages = {97-132},
numpages = {36},
location = {Cambridge, Massachusetts, USA},
series = {HOPL-II}
}
@article{algol68_with_fewer_tears_1968,
author = {Lindsey, C. H.},
title = {ALGOL68 with fewer tears},
year = {1968},
issue_date = {Jul. 1968},
publisher = {Computer History Museum},
address = {Mountain View, CA, USA},
number = {28},
issn = {0084-6198},
journal = {ALGOL Bull.},
month = jul,
pages = {9-49},
numpages = {41},
url = {https://dl.acm.org/doi/pdf/10.5555/1061112.1061116},
}
@article{the_algol_68_story_peck_1978,
  author    = {John E. Peck},
  title     = {The ALGOL 68 Story: A personal account by a member of the design team},
  journal   = {ACS Bulletin},
  volume    = {-},
  number    = {November 1978},
  pages     = {4--6},
  year      = {1978},
  month     = {November},
  url       = {https://www.softwarepreservation.org/projects/ALGOL/paper/The%20Algol%2068%20Story.pdf},
  note      = {Accessed 10-13-2025},
}
@misc{a_shorter_history_of_algol68_1994,
  author       = {C.,H.,A. Koster},
  title        = {A SHORTER HISTORY OF ALGOL68},
  howpublished = {Department of Computer Science, University of Nijmegen, The Netherlands},
  year         = {1994},
  note         = {180994 (identifier), email: kees@cs.kun.nl},
  url          = {https://web.archive.org/web/20071217203826/http://npt.cc.rsu.ru/user/wanderer/ODP/ALGOL68.txt},
}
@book{Bibliographie1973ProgrammingLanguages,
  title        = {Bibliographie Der Programmiersprachen: Bibliography of Programming Languages. Bibliographie Des Langages De Programmation},
  publisher    = {Verlag Dokumentation},
  address      = {Pullach/München},
  year         = {1973},
  edition      = {First Edition},
  isbn         = {3794036514},
  note         = {ISBN-13: 9783794036516, Language: English, Hardcover. It has been impossible to track down this book, please reach out if you have a copy.}
}
@misc{kernighan_interviews_thompson_2019,
  author       = {Ken Thompson},
  title        = {VCF East 2019 -- Brian Kernighan Interviews Ken Thompson},
  howpublished = {YouTube video},
  year         = {2019},
  month        = {May 6},
  url          = {https://www.youtube.com/watch?v=EY6q5dv_B-o},
  note         = {Retrieved October 14, 2025}
}
@article{cleaning_up_algol60_duncan_wijngaarden_1964,
author = {Duncan, F. G. and van Wijngaarden, A.},
title = {Cleaning up ALGOL60},
year = {1964},
issue_date = {May. 1964},
publisher = {Computer History Museum},
address = {Mountain View, CA, USA},
number = {16},
issn = {0084-6198},
journal = {ALGOL Bull.},
month = may,
pages = {24–32},
numpages = {9}
}
@Unpublished{orthogonal_design_and_description_of_a_formal_language_wijngaarden_1965,
 title                = {Orthogonal design and description of a formal language},
 author               = {van Wijngaarden, Adriaan},
 number               = {MR 76/65},
 year                 = 1965,
 month                = jan,
 url                  = {https://ir.cwi.nl/pub/9208/9208D.pdf}
}
@techreport{mr93_draft_report_on_algol_68_1968,
  title        = {Draft Report on the Algorithmic Language ALGOL 68},
  author       = {A. van Wijngaarden and B. J. Mailloux and J. E. L. Peck and C. H. A. Koster},
  institution  = {Mathematisch Centrum},
  address      = {Amsterdam},
  series       = {Mathematisch Centrum Report MR 93},
  year         = {1968},
  month        = {March},
  edition      = {Second printing},
  note         = {Commissioned by Working Group 2.1 on ALGOL of the International Federation for Information Processing. Supplement to ALGOL Bulletin 26},
  url          = {https://algol68-lang.org/docs/algol68-draft-report.pdf}
}
@article{successes_and_failures_of_the_algol_effort_naur_1968,
author = {Naur, Peter},
title = {Successes and failures of the ALGOL effort},
year = {1968},
issue_date = {Jul. 1968},
publisher = {Computer History Museum},
address = {Mountain View, CA, USA},
number = {28},
issn = {0084-6198},
journal = {ALGOL Bull.},
month = jul,
pages = {58–62},
numpages = {5}
}
@article{report_on_the_algorithmic_language_algol_68_mailloux_1969,
author = {Mailloux, B. J. and Peck, J. E. and Koster, C. H.},
title = {Report on the Algorithmic Language ALGOL 68},
year = {1969},
issue_date = {December  1969},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {14},
number = {2},
issn = {0029-599X},
url = {https://doi.org/10.1007/BF02163002},
doi = {10.1007/BF02163002},
journal = {Numer. Math.},
month = dec,
pages = {79-218},
numpages = {140}
}
@Unpublished{penultimate_draft_report_on_algol_68_1968,
  title                = {Penultimate draft report on the algorithmic language Algol 68, 1 : chapters 1-9},
  author               = {Mailloux, B.J. and Peck, J.E.L. and Koster, C.H.A.},
  number               = {MR 99/68},
  year                 = 1968,
  month                = jan
}
@misc{marchesi_gnu_cauldron_ga68_2025,
  author       = {José Marchesi},
  title        = {GA68: The GNU ALGOL 68 Compiler},
  howpublished = {YouTube video, GNU Tools Cauldron 2025 Conference, Porto, Portugal, September 26--28, 2025},
  year         = {2025},
  month        = {October 9},
  url          = {https://www.youtube.com/watch?v=3aMwC24EcJk&list=RQe2HRCqomoBtsS-ud3OO8RBgWKMo&t=390s},
  note         = {Published on the GNU Tools Cauldron YouTube channel, retrieved October 14, 2025}
}
@inproceedings{mcclure_tmg_compiler_compiler_1965,
author = {McClure, R. M.},
title = {Programming languages for non-numeric processing—1: TMG—a syntax directed compiler},
year = {1965},
isbn = {9781450374958},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800197.806050},
doi = {10.1145/800197.806050},
abstract = {THIS PAPER reports on a compiler writing system called TMG, basically a syntax directed system. It has, however, some interesting differences which make it easier to handle errors and declarative information. The original objective of this system was to make it as easy as possible to construct a simple one-pass translator for some specialized language.In TMG, emphasis is placed on scanning and analysis of input text and efficient production of straightforward translation of the input. For this reason, there are substantially no facilities for handling program topology, efficient register assignment, common subexpression removal, or complicated storage assignment. It was felt that, if required, these should be handled by a specially written post-processor.To explain how one writes a translator in TMGL, we will describe in some detail a compiler which translates a simple algebraic language (SAL) into symbolic machine code for the IBM 7040.},
booktitle = {Proceedings of the 1965 20th National Conference},
pages = {262–274},
numpages = {13},
location = {Cleveland, Ohio, USA},
series = {ACM '65}
}
@techreport{tmg_manual_mcilroy_1972,
  author       = {M. D. McIlroy},
  title        = {A Manual for the Tmg Compiler-writing Language},
  institution  = {Bell Laboratories, Murray Hill, New Jersey},
  type         = {Technical Memorandum},
  year         = {1972},
  month        = {September 13},
  url          = {https://amakukha.github.io/tmg/TMG_Manual_McIlroy_1972.html},
  note         = {Originally a Bell Laboratories internal report; scanned version accessed <insert date>}
}
@inproceedings{development_of_c_language_chist_ritchie_1996,
  author       = {Dennis M. Ritchie},
  title        = {The Development of the {C} Language},
  booktitle    = {History of Programming Languages II},
  editor       = {Thomas J. Bergin Jr. and Richard G. Gibson Jr.},
  year         = {1996},
  publisher    = {ACM Press and Addison-Wesley},
  address      = {New York, NY and Reading, MA},
  pages        = {671--698},
  note         = {Originally presented at the Second History of Programming Languages Conference (HOPL-II), Cambridge, MA, April 1993. Copyright {\textcopyright} 1993 ACM. Electronic reprint courtesy of the author.},
  isbn         = {0-201-89502-1},
  url          = {https://www.bell-labs.com/usr/dmr/www/chist.html},
  institution  = {Bell Labs/Lucent Technologies},
  email        = {dmr@bell-labs.com}
}
@article{bell_threaded_code_1973,
author = {Bell, James R.},
title = {Threaded code},
year = {1973},
issue_date = {June 1973},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {16},
number = {6},
issn = {0001-0782},
url = {https://doi.org/10.1145/362248.362270},
doi = {10.1145/362248.362270},
abstract = {The concept of “threaded code” is presented as an alternative to machine language code. Hardware and software realizations of it are given. In software it is realized as interpretive code not needing an interpreter. Extensions and optimizations are mentioned.},
journal = {Commun. ACM},
month = jun,
pages = {370–372},
numpages = {3},
keywords = {time tradeoff, threaded code, subroutine calls, space tradeoff, machine code, interpreter, compiled code}
}
@misc{aho_bell_labs_role_in_programming_languages_2025,
  author       = {Alfred V. Aho},
  title        = {Bell Labs' Role in Programming Languages and Algorithms},
  howpublished = {Lecture page, Simons Foundation},
  month        = feb,
  day          = {7},
  year         = {2019},
  url          = {https://www.simonsfoundation.org/event/bell-labs-role-in-programming-languages-and-algorithms/},
  note         = {Lecture description; accessed October 18, 2025}
}
@misc{Losh2020UnixHistory,
  author       = {Warner Losh},
  title        = {The Early History of Unix},
  howpublished = {Talk presented at FOSDEM 2020, Brussels, Belgium},
  year         = {2020},
  month        = {February},
  day          = {1},
  note         = {Room Janson, scheduled start 13:00. Video available on YouTube and FOSDEM archives.},
  url          = {https://www.youtube.com/watch?v=XuzeagzQwRs&t=2024s},
  url2         = {https://video.fosdem.org/2020/Janson/},
}
@misc{doug_mcilroy_oral_history_2019,
  author       = {Malcolm D. McIlroy},
  title        = {Oral History of Malcolm D. McIlroy},
  howpublished = {Interview transcript},
  institution  = {Computer History Museum},
  year         = {2019},
  month        = {September},
  note         = {Interviewed by David C. Brock. Catalogue number 102795421. CHM Oral History Collection, Etna, New Hampshire, USA. 59 pages.},
  url          = {https://www.computerhistory.org/collections/catalog/102795421/},
  publisher    = {Computer History Museum},
  address      = {Etna, NH, USA},
  language     = {English}
}
@unpublished{doug_mcilroy_origin_of_unix_pipes_1964,
  author       = {M. D. McIlroy},
  title        = {The Origin of Unix Pipes},
  note         = {Internal Bell Labs memorandum describing the concept of pipes prior to Unix.},
  institution  = {Bell Telephone Laboratories},
  address      = {Murray Hill, New Jersey},
  year         = {1964},
  month        = {October},
  day          = {11},
  url          = {https://doc.cat-v.org/unix/pipes/}
}
@INPROCEEDINGS{algol_68_ussr_2014,
  author={Terekhov, Andrey},
  booktitle={2014 Third International Conference on Computer Technology in Russia and in the Former Soviet Union},
  title={ALGOL 68 and Its Impact on the USSR and Russian Programming},
  year={2014},
  volume={},
  number={},
  pages={97-106},
  keywords={Computers;Programming;Educational institutions;Grammar;Optimization;Domain specific languages;Standards;ALGOL 68;translator;compiler;compiler technique;DSL;HLL computer;education;history of programming},
  doi={10.1109/SoRuCom.2014.29}}
@techreport{snyder_portable_compiler_for_c_1975,
author = {Snyder, A.},
title = {A Portable Compiler For The Language C},
year = {1975},
publisher = {Massachusetts Institute of Technology},
address = {USA},
abstract = {This paper describes the implementation of a compiler for the language C. The compiler has been designed to be able to be capable of producing assembly-language code for most register-oriented machines with only minor recoding. Most of the machine-dependent information used in code generation is contained in a set of tables which are constructed automatically from a machine description provided by the implementor. In the machine description, the implementor models the target machine by defining a machine-dependent abstract machine for which the code generator produces intermediate code. The abstract machine is abstract in that it is a C machine: its registers and memory are defined in terms of primitive C data types and its instructions perform basic C operations. The abstract machine is machine-dependent in that there is a close correspondence between the registers of the abstract machine and those of the target machine, and between the behavior of the abstract machine instructions and the corresponding target machine instructions or instruction sequences. The implementor defines the corresponding target machine instructions or instruction sequences. The implementor defines the translation from an abstract machine program to a target machine program by providing in the machine description a set of simple macro definitions for the abstract machine instructions. In addition, macro definitions may be provided in the form of C routines where additional processing capability is needed. {AD A010-218}}
}
@book{the_c_programming_language_1ed_ritchie_kernighan_1989,
author = {Kernighan, Brian W. and Ritchie, Dennis M.},
title = {The C programming language},
year = {1989},
isbn = {0131103628},
publisher = {Prentice Hall Press},
address = {USA},
abstract = {This ebook is the first authorized digital version of Kernighan and Ritchies 1988 classic, The C Programming Language (2nd Ed.). One of the best-selling programming books published in the last fifty years, K&R has been called everything from the bible to a landmark in computer science and it has influenced generations of programmers. Available now for all leading ebook platforms, this concise and beautifully written text is a must-have reference for every serious programmers digital library. As modestly described by the authors in the Preface to the First Edition, this is not an introductory programming manual; it assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. Nonetheless, a novice programmer should be able to read along and pick up the language, although access to a more knowledgeable colleague will help.}
}
@book{aho_hopcroft_algorithms_1974,
author = {Aho, Alfred V. and Hopcroft, John E.},
title = {The Design and Analysis of Computer Algorithms},
year = {1974},
isbn = {0201000296},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
address = {USA},
edition = {1st},
abstract = {From the Publisher: With this text, you gain an understanding of the fundamental concepts of algorithms, the very heart of computer science. It introduces the basic data structures and programming techniques often used in efficient algorithms. Covers use of lists, push-down stacks, queues, trees, and graphs. Later chapters go into sorting, searching and graphing algorithms, the string-matching algorithms, and the Schonhage-Strassen integer-multiplication algorithm. Provides numerous graded exercises at the end of each chapter. 0201000296B04062001}
}
@inbook{yacc_a_parser_generator_johnson_sethi_1990,
author = {Johnson, Stephen C. and Sethi, Ravi},
title = {Yacc: a parser generator},
year = {1990},
isbn = {0030475295},
publisher = {W. B. Saunders Company},
address = {USA},
booktitle = {UNIX Vol. II: Research System (10th Ed.)},
pages = {347–374},
numpages = {28}
}
@misc{johnson_yacc_mailing_list_2019,
  author       = {Steve Johnson},
  title        = {Re: What year was YACC born?},
  howpublished = {Email message to Eric S. Raymond, archived on the TUHS mailing list},
  year         = {2019},
  month        = {February},
  day          = {13},
  note         = {Quoted in message from Eric S. Raymond titled \textit{Steve Johnson's reply}, posted to the TUHS mailing list. Provides a first-hand account of the origins and early development of Yacc at Bell Labs.},
  url          = {https://minnie.tuhs.org/pipermail/tuhs/2019-February/017065.html}
}
@article{kernighan_cherry_eqn_1975,
author = {Kernighan, Brian W. and Cherry, Lorinda L.},
title = {A system for typesetting mathematics},
year = {1975},
issue_date = {March 1975},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/360680.360684},
doi = {10.1145/360680.360684},
abstract = {This paper describes the design and implementation of a system for typesetting mathematics. The language has been designed to be easy to learn and to use by people (for example, secretaries and mathematical typists) who know neither mathematics nor typesetting. Experience indicates that the language can be learned in an hour or so, for it has few rules and fewer exceptions. For typical expressions, the size and font changes, positioning, line drawing, and the like necessary to print according to mathematical conventions are all done automatically. For example, the input sum from i=0 to infinity x sub i = pi over 2 produces ∑∞i=0xi = π/2The syntax of the language is specified by a small context-free grammar; a compiler-compiler is used to make a compiler that translates this language into typesetting commands. Output may be produced on either a phototypesetter or on a terminal with forward and reverse half-line motions. The system interfaces directly with text formatting programs, so mixtures of text and mathematics may be handled simply.This paper was typeset by the authors using the system described.},
journal = {Commun. ACM},
month = mar,
pages = {151–157},
numpages = {7},
keywords = {typesetting, text processing, printing, photo-composition, graphics, compiler-compiler}
}
@ARTICLE{brief_history_of_foss_2021,
author={Gonzalez-Barahona, Jesus M.},
journal={ Computer },
title={{ A Brief History of Free, Open Source Software and Its Communities }},
year={2021},
volume={54},
number={02},
ISSN={1558-0814},
pages={75-79},
abstract={ Free, open source software (FOSS) has a long history, beginning with the origins of software itself, when the terms free software and open source software were not yet defined. Learning about the milestones of this history may help to understand FOSS today. },
keywords={Open source software;Licenses;Internet},
doi={10.1109/MC.2020.3041887},
url = {https://doi.ieeecomputersociety.org/10.1109/MC.2020.3041887},
publisher={IEEE Computer Society},
address={Los Alamitos, CA, USA},
month=feb}

@book{laning_zierler_algebraic_compiler_manual_1954,
  title={A program for translation of mathematical equations for Whirlwind I},
  author={Laning, J Halcombe and Zierler, Neal},
  year={1954},
  publisher={Instrumentation Laboratory, Massachusetts Institute of Technology},
  url={https://archive.computerhistory.org/resources/text/Fortran/102653982.05.01.acc.pdf},
  url2={https://www.softwarepreservation.org/projects/FORTRAN/paper/Laning%20and%20Zierler%201954.pdf}
}
@article{hopl_history_of_ml_2020,
author = {MacQueen, David and Harper, Robert and Reppy, John},
title = {The History of Standard ML},
year = {2020},
issue_date = {June 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {HOPL},
url = {https://doi.org/10.1145/3386336},
doi = {10.1145/3386336},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {86},
numpages = {100},
keywords = {Language design, Operational semantics, Standard ML, Type checking}
}
@book{backus_fortran_ref_manual_1956,
author = {Backus, J. W. and Beeber, R. J. and Best, S. and Goldberg, R. and Herrick, H. L. and Hughes, R. A. and Mitchell, L. B. and Nelson, R. A. and Nutt, R. and Sayre, D. and Sheridan, P. B. and Stern, H. and Ziller, L.},
title = {Fortran: Automatic Coding System for the IBM 704 EDPM},
year = {1956},
url={http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/704/704_FortranProgRefMan_Oct56.pdf},
url2={https://www.softwarepreservation.org/projects/FORTRAN/manual/Addenda_to_FORTRAN_Prog_Ref_Manual.pdf},
note={The addenda were published in 1957.}
}
@ARTICLE{11030926,
author={Ceruzzi, Paul},
journal={IEEE Annals of the History of Computing},
title={Review of Konrad Zuse’s Early Computers: The Quest for the Computer in Germany, by Raúl Rojas},
year={2025},
volume={47},
number={2},
pages={60-61},
keywords={Book reviews;Computers;History},
doi={10.1109/MAHC.2025.3560208}}

@article{ceruzzi_early_computers_of_zuse_1981,
author = {Ceruzzi, Paul E.},
title = {The Early Computers of Konrad Zuse, 1935 to 1945},
year = {1981},
issue_date = {July 1981},
publisher = {IEEE Educational Activities Department},
address = {USA},
volume = {3},
number = {3},
issn = {1058-6180},
url = {https://doi.org/10.1109/MAHC.1981.10034},
doi = {10.1109/MAHC.1981.10034},
abstract = {This paper examines in detail the early work of Zuse, beginning with his first thoughts on mechanizing calculation in the 1930s and continuing through the completion of his general-purpose relay computer, the Z4, in 1945. The primary objective of this paper is to describe the machines Zuse constructed, but in addition it examines the social, technical, and political milieu in which he carried out his work.},
journal = {IEEE Ann. Hist. Comput.},
month = jul,
pages = {241–262},
numpages = {22}
}
@inbook{rojas_arch_of_zuses_machines_2000,
author = {Rojas, Ra\'{u}l},
title = {The architecture of Konrad Zuse's early computing machines},
year = {2000},
isbn = {0262181975},
publisher = {MIT Press},
address = {Cambridge, MA, USA},
booktitle = {The First Computers: History and Architectures},
pages = {237–261},
numpages = {25}
}
@online{zuse2009life,
author       = {Horst Zuse},
title        = {The Life and Work of Konrad Zuse},
year         = {2009},
howpublished = {EPE Online Magazine},
url          = {https://web.archive.org/web/20100418164050/http://www.epemag.com/zuse/},
note         = {Archived from the original on 29 June 2009. Retrieved 18 April 2010 via the Internet Archive.}
}
@book{hohmann1979plankalkul,
title={Der Plankalk{\"u}l im Vergleich mit algorithmischen Sprachen},
author={Hohmann, J.},
isbn={9783878200284},
lccn={80472200},
series={Informatik und Operations Research},
url={https://books.google.com/books?id=f_dLAAAACAAJ},
year={1979},
publisher={Toeche-Mittler}
}
@misc{zuse_lecture_1976,
author       = {Konrad Zuse},
title        = {Lecture by Konrad Zuse},
year         = {1976},
howpublished = {Moving image (Betacam SP)},
note         = {Catalogue number 102639685. Gift of FIC. Extent: 00:12:22. Recorded in Los Alamos, NM, USA.},
organization = {Computer History Museum},
address      = {Los Alamos, NM, USA},
url          = {https://www.computerhistory.org/collections/catalog/102639685},
url2         = {https://www.youtube.com/watch?v=UHOU_FlLsHc&list=WL&index=1},
yearfiled    = {2002},
}
@inproceedings{backus_etal_fortran_automatic_coding_system_1957,
author = {Backus, J. W. and Beeber, R. J. and Best, S. and Goldberg, R. and Haibt, L. M. and Herrick, H. L. and Nelson, R. A. and Sayre, D. and Sheridan, P. B. and Stern, H. and Ziller, I. and Hughes, R. A. and Nutt, R.},
title = {The FORTRAN automatic coding system},
year = {1957},
isbn = {9781450378611},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1455567.1455599},
doi = {10.1145/1455567.1455599},
abstract = {The FORTRAN project was begun in the summer of 1954. Its purpose was to reduce by a large factor the task of preparing scientific problems for IBM's next large computer, the 704. If it were possible for the 704 to code problems for itself and produce as good programs as human coders (but without the errors), it was clear that large benefits could be achieved. For it was known that about two-thirds of the cost of solving most scientific and engineering problems on large computers was that of problem preparation. Furthermore, more than 90 per cent of the elapsed time for a problem was usually devoted to planning, writing, and debugging the program. In many cases the development of a general plan for solving a problem was a small job in comparison to the task of devising and coding machine procedures to carry out the plan. The goal of the FORTRAN project was to enable the programmer to specify a numerical procedure using a concise language like that of mathematics and obtain automatically from this specification an efficient 704 program to carry out the procedure. It was expected that such a system would reduce the coding and debugging task to less than one-fifth of the job it had been.},
booktitle = {Papers Presented at the February 26-28, 1957, Western Joint Computer Conference: Techniques for Reliability},
pages = {188–198},
numpages = {11},
location = {Los Angeles, California},
series = {IRE-AIEE-ACM '57 (Western)}
}
@article{lamport_should_lang_be_typed_1999,
author = {Lamport, Leslie and Paulson, Lawrence C.},
title = {Should your specification language be typed},
year = {1999},
issue_date = {May 1999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/319301.319317},
doi = {10.1145/319301.319317},
abstract = {Most specification languages have a type system. Type systems are hard to get right, and getting them wrong can lead to inconsistencies. Set theory can serve as the basis for a specification language without types. This possibility, which has been widely overlooked, offers many advantages. Untyped set theory is simple and is more flexible than any simple typed formalism. Polymorphism, overloading, and subtyping can make a type system more powerful, but at the cost of increased somplexity, and such refinements can never attain the flexibility of having no types at all. Typed formalisms have advantages, too, stemming from the power of mechanical type checking. While types serve little purpose in hand proofs, they do help with mechanized proofs. In the absence of verificaiton, type   checking can catch errors in specifications. It may be possible to have the best of both worlds by adding typing annotations to an untyped specification language.We consider only specification languages, not programming languages.},
journal = {ACM Trans. Program. Lang. Syst.},
month = may,
pages = {502–526},
numpages = {25},
keywords = {types, specification, set theory}
}
@article{backus_can_liberated_from_vn_style_1978,
author = {Backus, John},
title = {Can programming be liberated from the von Neumann style? a functional style and its algebra of programs},
year = {1978},
issue_date = {Aug. 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/359576.359579},
doi = {10.1145/359576.359579},
abstract = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor—the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs.An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose “unknowns” are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs.A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states—only one state transition occurs per major computation.},
journal = {Commun. ACM},
month = aug,
pages = {613–641},
numpages = {29},
keywords = {algebra of programs, applicative computing systems, applicative state transition systems, combining forms, functional forms, functional programming, metacomposition, models of computing systems, program correctness, program termination, program transformation, programming languages, von Neumann computers, von Neumann languages}
}
@book{programming_languages_and_their_compilers_1969,
author = {Cocke, John},
title = {Programming languages and their compilers: Preliminary notes},
year = {1969},
isbn = {B0007F4UOA},
publisher = {New York University},
url={https://www.softwarepreservation.org/projects/FORTRAN/CockeSchwartz_ProgLangCompilers.pdf},
address = {USA}
}
@techreport{fortran_ii_proposal_1957,
  author       = {{Programming Research Department, International Business Machines Corporation}},
  title        = {Proposed Specifications for {FORTRAN} II for the IBM 704},
  type         = {Internal report},
  institution  = {International Business Machines Corporation},
  department   = {Programming Research Department},
  address      = {590 Madison Avenue, New York, NY 10022 (NY 22)},
  year         = {1957},
  month        = {September},
  day          = {25},
  note         = {Internal technical specification; IBM 704 FORTRAN II proposal},
  url={https://archive.computerhistory.org/resources/text/Fortran/102663106.05.01.acc.pdf},
}
@incollection{programming_language_pragmatics_2009,
editor = {Michael L. Scott},
booktitle = {Programming Language Pragmatics (Third Edition)},
publisher = {Morgan Kaufmann},
edition = {Third Edition},
address = {Boston},
pages = {111-173},
year = {2009},
isbn = {978-0-12-374514-9},
doi = {https://doi.org/10.1016/B978-0-12-374514-9.00012-4},
url = {https://www.sciencedirect.com/science/article/pii/B9780123745149000124},
author = {Michael L. Scott}
}
@inbook{mccarthy_history_of_lisp_1978,
author = {McCarthy, John},
title = {History of LISP},
year = {1978},
isbn = {0127450408},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800025.1198360},
booktitle = {History of Programming Languages},
pages = {173–185},
numpages = {13}
}
@ARTICLE{backus_heising_fortran_1964,
author={Backus, J. W. and Heising, W. P.},
journal={IEEE Transactions on Electronic Computers},
title={Fortran},
year={1964},
volume={EC-13},
number={4},
pages={382-385},
keywords={Programming profession;High level languages;Scientific computing;Layout;Program processors;Computer languages;Atmosphere;Computer industry;Humans;Data systems},
doi={10.1109/PGEC.1964.263818}
}
@book{cress_dirksen_graham_watfor_fortran_iv_1970,
author = {Cress, Paul and Dirksen, Paul and Graham, J. Wesley},
title = {FORTRAN IV with WATFOR and WATFIV},
year = {1970},
isbn = {0133294331},
publisher = {Prentice Hall Press},
address = {USA}
}
@inproceedings{brown_carr_automatic_onr_symposium_1954,
	address = {Washington, {D.C.}},
	title = {Automatic Programming and Its Development on the {MIDAC}},
	booktitle = {Symposium on Automatic Programming for Digital Computers, Office of Naval Research, Department of the Navy, Washington, {D.C.}, 13-14 May 1954},
	publisher = {{U.S.} Dept. of Commerce, Office of Technical Services},
	author = {Brown, J. H. and Carr {III}, John W.},
	year = {1954},
	pages = {84--97}
}
@inproceedings{10.1145/2500365.2500618,
author = {Keep, Andrew W. and Dybvig, R. Kent},
title = {A nanopass framework for commercial compiler development},
year = {2013},
isbn = {9781450323260},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2500365.2500618},
doi = {10.1145/2500365.2500618},
abstract = {Contemporary compilers must typically handle sophisticated high-level source languages, generate efficient code for multiple hardware architectures and operating systems, and support source-level debugging, profiling, and other program development tools. As a result, compilers tend to be among the most complex of software systems. Nanopass frameworks are designed to help manage this complexity. A nanopass compiler is comprised of many single-task passes with formally defined intermediate languages. The perceived downside of a nanopass compiler is that the extra passes will lead to substantially longer compilation times. To determine whether this is the case, we have created a plug replacement for the commercial Chez Scheme compiler, implemented using an updated nanopass framework, and we have compared the speed of the new compiler and the code it generates against the original compiler for a large set of benchmark programs. This paper describes the updated nanopass framework, the new compiler, and the results of our experiments. The compiler produces faster code than the original, averaging 15-27\% depending on architecture and optimization level, due to a more sophisticated but slower register allocator and improvements to several optimizations. Compilation times average well within a factor of two of the original compiler, despite the slower register allocator and the replacement of five passes of the original 10 with over 50 nanopasses.},
booktitle = {Proceedings of the 18th ACM SIGPLAN International Conference on Functional Programming},
pages = {343–350},
numpages = {8},
keywords = {scheme, nanopass, compiler},
location = {Boston, Massachusetts, USA},
series = {ICFP '13}
}

@article{keep_dybvig_nanopass_2013,
author = {Keep, Andrew W. and Dybvig, R. Kent},
title = {A nanopass framework for commercial compiler development},
year = {2013},
issue_date = {September 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2544174.2500618},
doi = {10.1145/2544174.2500618},
abstract = {Contemporary compilers must typically handle sophisticated high-level source languages, generate efficient code for multiple hardware architectures and operating systems, and support source-level debugging, profiling, and other program development tools. As a result, compilers tend to be among the most complex of software systems. Nanopass frameworks are designed to help manage this complexity. A nanopass compiler is comprised of many single-task passes with formally defined intermediate languages. The perceived downside of a nanopass compiler is that the extra passes will lead to substantially longer compilation times. To determine whether this is the case, we have created a plug replacement for the commercial Chez Scheme compiler, implemented using an updated nanopass framework, and we have compared the speed of the new compiler and the code it generates against the original compiler for a large set of benchmark programs. This paper describes the updated nanopass framework, the new compiler, and the results of our experiments. The compiler produces faster code than the original, averaging 15-27\% depending on architecture and optimization level, due to a more sophisticated but slower register allocator and improvements to several optimizations. Compilation times average well within a factor of two of the original compiler, despite the slower register allocator and the replacement of five passes of the original 10 with over 50 nanopasses.},
journal = {SIGPLAN Not.},
month = sep,
pages = {343–350},
numpages = {8},
keywords = {scheme, nanopass, compiler}
}
@InCollection{stanford_encyclopedia_church_2025,
	author       =	{Deutsch, Harry and Marshall, Oliver},
	title        =	{{Alonzo Church}},
	booktitle    =	{The {Stanford} Encyclopedia of Philosophy},
	editor       =	{Edward N. Zalta and Uri Nodelman},
	howpublished =	{\url{https://plato.stanford.edu/archives/spr2025/entries/church/}},
	year         =	{2025},
	edition      =	{{S}pring 2025},
	publisher    =	{Metaphysics Research Lab, Stanford University}
}
@article{church_simple_theory_of_types_1940,
 ISSN = {00224812},
 URL = {http://www.jstor.org/stable/2266170},
 URL2 = {https://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf},
 author = {Alonzo Church},
 journal = {The Journal of Symbolic Logic},
 number = {2},
 pages = {56--68},
 publisher = {Association for Symbolic Logic},
 title = {A Formulation of the Simple Theory of Types},
 urldate = {2025-10-27},
 volume = {5},
 year = {1940}
}
@article{curry_functionality_in_combinatory_logic_1934,
 ISSN = {00278424, 10916490},
 URL = {http://www.jstor.org/stable/86796},
 author = {H. B. Curry},
 journal = {Proceedings of the National Academy of Sciences of the United States of America},
 number = {11},
 pages = {584--590},
 publisher = {National Academy of Sciences},
 title = {Functionality in Combinatory Logic},
 urldate = {2025-10-27},
 volume = {20},
 year = {1934}
}
@book{hindley_basic_type_theory_1997,
author = {Hindley, J. Roger},
title = {Basic simple type theory},
year = {1997},
isbn = {0521465184},
publisher = {Cambridge University Press},
address = {USA}
}
@inbook{mccarthy_programs_with_common_sense_1958,
author = {McCarthy, John},
title = {Programs with common sense},
year = {1959},
isbn = {0262621010},
publisher = {American Association for Artificial Intelligence},
address = {USA},
booktitle = {Computation \& Intelligence: Collected Readings},
pages = {479–492},
numpages = {14}
}
@article{gelernter_flpl_1960,
author = {Gelernter, H. and Hansen, J. R. and Gerberich, C. L.},
title = {A Fortran-Compiled List-Processing Language},
year = {1960},
issue_date = {April 1960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/321021.321022},
doi = {10.1145/321021.321022},
abstract = {A compiled computer language for the manipulation of symbolic expressions organized in storage as Newell-Shaw-Simon lists has been developed as a tool to make more convenient the task of programming the simulation of a geometry theorem-proving machine on the IBM 704 high-speed electronic digital computer. Statements in the language are written in usual Fortran notation, but with a large set of special list-processing functions appended to the standard Fortran library. The algebraic structure of certain statements in this language corresponds closely to the structure of an NSS list, making possible the generation and manipulation of complex list expressions with a single statement. The many programming advantages accruing from the use of Fortran, and in particular, the ease with which massive and complex programs may be revised, combined with the flexibility offered by an NSS list organization of storage make the language particularly useful where, as in the case of our theorem-proving program, intermediate data of unpredictable form, complexity, and length may be generated.},
journal = {J. ACM},
month = apr,
pages = {87–101},
numpages = {15}
}
@article{mccarthy_recursive_functions_computation_1960,
author = {McCarthy, John},
title = {Recursive functions of symbolic expressions and their computation by machine, Part I},
year = {1960},
issue_date = {April 1960},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {4},
issn = {0001-0782},
url = {https://doi.org/10.1145/367177.367199},
doi = {10.1145/367177.367199},
journal = {Commun. ACM},
month = apr,
pages = {184–195},
numpages = {12}
}
@book{structured_programming_1972,
editor = {Dahl, O. J. and Dijkstra, E. W. and Hoare, C. A. R.},
title = {Structured programming},
year = {1972},
isbn = {0122005503},
publisher = {Academic Press Ltd.},
address = {GBR},
abstract = {In recent years there has been an increasing interest in the art of computer programming, the conceptual tools available for the design of programs, and the prevention of programming oversights and error. The initial outstanding contribution to our understanding of this subject was made by E. W. Dijkstra, whose Notes on Structured Programming form the first and major section of this book. They clearly expound the reflections of a brilliant programmer on the methods which he has hitherto unconsciously applied; there can be no programmer of the present day who could not increase his skills by a study and conscious application of these principles.In the second monograph I have tried to describe how similar principles can be applied in the design of data structures. I have suggested that in analysing a problem and groping towards a solution, a programmer should take advantage of abstract concepts such as sets, sequences, and mappings; and judiciously postpone decisions on representation until he is constructing the more detailed code of the program. The monograph also describes a range of useful ideas for data representation, and suggests the criteria relevant for their selection.The third monograph provides a synthesis of the previous two, and expounds the close theoretical and practical connections between the design of data and the design of programs. It introduces useful additional methods for program and data structuring which may be unfamiliar to many programmers. The examples show that structured programming principles can be equally applied in "bottom-up" as in "top-down" program design. The original inspiration, insight, and all the examples were contributed by O.-J. Dahl; I have only assembled the material, and added some additional explanations where I found it difficult to understand.}
}
@misc{type_theory_for_all_david_macqueen_2025,
  author       = {{Type Theory For All (podcast)}},
  title        = {Bell Labs},
  howpublished = {Podcast episode (interview with David MacQueen)},
  month        = {January},
  day          = {25},
  year         = {2025},
  url          = {https://www.typetheoryforall.com/episodes/bell-labs},
  note         = {Accessed 2025-10-29. Summary: David MacQueen (Emeritus, University of Chicago) discusses his 20 years at Bell Labs — its technology, people, and management during the institution's golden age.}
}
@book{bjarne_stroustrup_design_of_cpp_1995,
author = {Stroustrup, Bjarne},
title = {The design and evolution of C++},
year = {1995},
isbn = {0201543303},
publisher = {ACM Press/Addison-Wesley Publishing Co.},
address = {USA}
}
@article{trusting_trust_1984,
author = {Thompson, Ken},
title = {Reflections on trusting trust},
year = {1984},
issue_date = {Aug 1984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/358198.358210},
doi = {10.1145/358198.358210},
abstract = {To what extent should one trust a statement that a program is free of Trojan horses? Perhaps it is more important to trust the people who wrote the software.},
journal = {Commun. ACM},
month = aug,
pages = {761–763},
numpages = {3}
}
@article{10.1145/1879097.1879081,
author = {Sward, Ricky E.},
title = {The rise, fall and persistence of Ada},
year = {2010},
issue_date = {December 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {30},
number = {3},
issn = {1094-3641},
url = {https://doi.org/10.1145/1879097.1879081},
doi = {10.1145/1879097.1879081},
abstract = {This paper begins with a brief history of the Ada programming language including the rise of Ada, the Ada Mandate and the fall from grace as a DoD programming language. The paper examines the reasons why the Ada is not widely accepted in certain areas and provides reasons why it should be used in particular areas. The paper then gives examples of where Ada has persisted and found a niche in safety critical, high integrity. The paper also discusses Ada-related organizations and gives examples of projects currently underway in the US and in Europe providing a compelling reason for using Ada in appropriate and critical domain areas.},
journal = {Ada Lett.},
month = oct,
pages = {71–74},
numpages = {4},
keywords = {safety critical, history of ada, high integrity, ada programming language}
}
@inproceedings{sward_rise_fall_ada_2010,
author = {Sward, Ricky E.},
title = {The rise, fall and persistence of Ada},
year = {2010},
isbn = {9781450300278},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1879063.1879081},
doi = {10.1145/1879063.1879081},
abstract = {This paper begins with a brief history of the Ada programming language including the rise of Ada, the Ada Mandate and the fall from grace as a DoD programming language. The paper examines the reasons why the Ada is not widely accepted in certain areas and provides reasons why it should be used in particular areas. The paper then gives examples of where Ada has persisted and found a niche in safety critical, high integrity. The paper also discusses Ada-related organizations and gives examples of projects currently underway in the US and in Europe providing a compelling reason for using Ada in appropriate and critical domain areas.},
booktitle = {Proceedings of the ACM SIGAda Annual International Conference on SIGAda},
pages = {71–74},
numpages = {4},
keywords = {safety critical, history of ada, high integrity, ada programming language},
location = {Fairfax, Virginia, USA},
series = {SIGAda '10}
}
@article{wirth_50_years_of_pascal_2021,
author = {Wirth, Niklaus},
title = {50 years of Pascal},
year = {2021},
issue_date = {March 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {64},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/3447525},
doi = {10.1145/3447525},
abstract = {The Pascal programming language creator Niklaus Wirth reflects on its origin, spread, and further development.},
journal = {Commun. ACM},
month = feb,
pages = {39–41},
numpages = {3}
}
@inbook{nygaard_development_simula_languages_78,
author = {Nygaard, Kristen and Dahl, Ole-Johan},
title = {The development of the SIMULA languages},
year = {1978},
isbn = {0127450408},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800025.1198392},
booktitle = {History of Programming Languages},
pages = {439–480},
numpages = {42}
}
@inbook{steele_evolution_lisp_96,
author = {Steele, Guy L. and Gabriel, Richard P.},
title = {The evolution of Lisp},
year = {1996},
isbn = {0201895021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/234286.1057818},
abstract = {Lisp is the world's greatest programming language---or so its proponents think. The structure of Lisp makes it easy to extend the language or even to implement entirely new dialects without starting from scratch. Overall, the evolution of Lisp has been guided more by institutional rivalry, one-upsmanship, and the glee born of technical cleverness that is characteristic of the "hacker culture" than by sober assessments of technical requirements. Nevertheless, this process has eventually produced both an industrial-strength programming languages, messy but powerful, and a technically pure dialect, small but powerful, that is suitable for use by programming-language theoreticians.We pick up where McCarthy's paper in the first HOPL conference left off. We trace the development chronologically from the era of the PDP-6, through the heyday of Interlisp and MacLisp, past the ascension and decline of special purpose Lisp machines, to the present era of standardization activities. We then examine the technical evolution of a few representative language features, including some notable successes and failures that illuminate design issues that distinguish Lisp from other programming languages. We also discuss the use of Lisp as a laboratory for designing other programming languages. We conclude with some reflections on the forces that have driven the evolution of Lisp.},
booktitle = {History of Programming Languages---II},
pages = {233–330},
numpages = {98}
}
@unpublished{graham_roots_of_lisp_2002,
  author = {Graham, Paul},
  title = {The Roots of Lisp},
  note = {Draft},
  year = {2002},
  month = jan,
  day = {18},
  url = {https://languagelog.ldc.upenn.edu/myl/llog/jmc.pdf}
}
@article{moses_function_of_function_1970,
author = {Moses, Joel},
title = {The function of FUNCTION in LISP or why the FUNARG problem should be called the environment problem},
year = {1970},
issue_date = {July 1970},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
number = {15},
issn = {0163-5824},
url = {https://doi.org/10.1145/1093410.1093411},
doi = {10.1145/1093410.1093411},
abstract = {A problem common to many powerful programming languages arises when one has to determine what values to assign to free variables in functions. Different implementational approaches which attempt to solve the problem are considered. The discussion concentrates on LISP implementations and points out why most current LISP systems are not as general as the original LISP 1.5 system. Readers not familiar with LISP should be able to read this paper without difficulty since we have tried to couch the argument in ALGOL-like terms as much as possible.},
journal = {SIGSAM Bull.},
month = jul,
pages = {13–27},
numpages = {15}
}
@unpublished{weizenbaum_funarg_explained_1968,
  author       = {Weizenbaum, Joseph},
  title        = {The {FUNARG} Problem Explained},
  note         = {Massachusetts Institute of Technology, Cambridge, MA. URL: \url{https://softwarepreservation.computerhistory.org/LISP/MIT/Weizenbaum-FUNARG_Problem_Explained-1968.pdf}},
  month        = mar,
  year         = {1968}
}
@article{blair_structure_lisp_compiler_1971,
  title={The structure of the LISP compiler},
  author={Blair, Fred},
  journal={Unpublished paper},
  url={https://softwarepreservation.computerhistory.org/LISP/ibm/Blair-StructureOfLispCompiler.pdf},
  year={1971}
}
@book{allen_anatomy_of_lisp_1978,
author = {Allen, John},
title = {Anatomy of LISP},
year = {1978},
isbn = {007001115X},
publisher = {McGraw-Hill, Inc.},
address = {USA},
abstract = {This text is nominally about LISP and data structures. However, in the process it covers much broader areas of computer science. The author has long felt that the beginning student of computer science has been getting' a distorted and disjointed picture of the field. In some ways this confusion is natural; the field has been growing at such a rapid rate that few are prepared to be judged experts in all areas of the discipline. The current alternative seems to be to give a few introductory courses in programming and machine organization followed by relatively specialized courses in more technical areas. The difficulty with this approach is that much of the technical material never gets related. The student's perspective and motivation suffer in the process. This book uses LISP as a means for relating topics which normally get treated in several separate courses. The point is not that we can do this in LISP, but rather that it is natural to do it in LISP. The high-level notation for algorithms is beneficial in explaining and understanding complex algorithms. The use of abstract data structures and abstract LISP programs shows the intent of structured programming and step-wise refinement. Much of the current work in mathematical theories of computation is based on LISP-like languages. Thus LISP is a formalism for describing algorithms, for writing programs, and for proving properties of algorithms. We use data structures as the main thread in our discussions because a proper appreciation of data structures as abstract objects is a necessary prerequisite to an understanding of modern computer science.}
}
@article{landin_eval_of_expressions_1964,
  title={The mechanical evaluation of expressions},
  author={Landin, Peter J},
  journal={The computer journal},
  volume={6},
  number={4},
  pages={308--320},
  year={1964},
  publisher={The British Computer Society}
}
@article{akera_voluntarism_ibm_share_2001,
 ISSN = {0040165X, 10973729},
 URL = {http://www.jstor.org/stable/25147801},
 author = {Atsushi Akera},
 journal = {Technology and Culture},
 number = {4},
 pages = {710--736},
 publisher = {[The Johns Hopkins University Press, Society for the History of Technology]},
 title = {Voluntarism and the Fruits of Collaboration: The IBM User Group, Share},
 urldate = {2025-10-30},
 volume = {42},
 year = {2001}
}
@article{armer_share_eulogy_1980,
author = {Armer, Paul},
title = {SHARE-A Eulogy to Cooperative Effort},
year = {1980},
issue_date = {October 31, 1956},
publisher = {IEEE Educational Activities Department},
address = {USA},
volume = {2},
number = {2},
issn = {1058-6180},
url = {https://doi.org/10.1109/MAHC.1980.10013},
doi = {10.1109/MAHC.1980.10013},
abstract = {Whenever someone asks about SHARE, the first question is usually "What do the initials mean?" The answer is that SHARE is a name and not a set of initials. The second question is usually "Just what is SHARE?" SHARE has been frequently described as a "users' cooperative." It is made up of most of the organizations who have, or plan on getting, an IBM Type 704 EDPM. Like any cooperative, SHARE was formed to be of service to its members. Its aim is to eliminate, as much as possible, redundant effort expended in using the 704. It seeks to accomplish this aim by promoting cooperation and communication among installations that use the 704.},
journal = {IEEE Ann. Hist. Comput.},
month = apr,
pages = {122–129},
numpages = {8}
}
@article{olsen_altac_fortranii_translator_1965,
author = {Olsen, Thomas M.},
title = {Philco/IBM translation at problem-oriented, symbolic and binary levels},
year = {1965},
issue_date = {Dec. 1965},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {12},
issn = {0001-0782},
url = {https://doi.org/10.1145/365691.365933},
doi = {10.1145/365691.365933},
journal = {Commun. ACM},
month = dec,
pages = {762–768},
numpages = {7}
}
@article{oswald_various_fortrans_datamation_1964,
  author    = {Oswald, H.},
  title     = {The Various FORTRANS},
  journal   = {Datamation},
  volume    = {10},
  number    = {8},
  year      = {1964},
  month     = aug,
  pages     = {25--29},
  url={https://bitsavers.org/magazines/Datamation/196408.pdf}
}
@article{allen_share_translator_datamation_1963,
  author    = {Allen, J. J. and Moore, D. P. and Rogoway, H. P.},
  title     = {SHARE Internal FORTRAN Translator},
  journal   = {Datamation},
  volume    = {9},
  number    = {3},
  year      = {1963},
  month     = march,
  pages     = {43--46},
  url={https://bitsavers.org/magazines/Datamation/196303.pdf}
}
@article{cardone_hindley_history_of_lambda_calcl_2006,
  title={History of lambda-calculus and combinatory logic},
  author={Cardone, Felice and Hindley, J Roger},
  journal={Handbook of the History of Logic},
  volume={5},
  pages={723--817},
  year={2006},
  url={https://api.semanticscholar.org/CorpusID:123879682},
  publisher={Elsevier, Amsterdam, to appear}
}
@book{hindley_lambda_calc_intro_2008,
  title={Lambda-Calculus and Combinators: An Introduction},
  author={Hindley, J.R. and Seldin, J.P.},
  isbn={9781139473248},
  url={https://books.google.com/books?id=9fhujocrM7wC},
  year={2008},
  publisher={Cambridge University Press}
}
@article{schonfinkel_invented_cl_building_blocks_math_1967,
  title={On the building blocks of mathematical logic},
  author={Sch{\"o}nfinkel, Moses},
  journal={From Frege to G{\"o}del},
  pages={355--366},
  year={1967},
  publisher={Harvard University Press Cambridge MA}
}
@article{neumann_axiom_set_theory_1925,
  title={Eine Axiomatisierung der Mengenlehre.},
  author={Neumann, J von},
  year={1925},
  publisher={Walter de Gruyter, Berlin/New York Berlin, New York}
}
@article{curry_phd_thesis_1930,
 ISSN = {00029327, 10806377},
 URL = {http://www.jstor.org/stable/2370716},
 author = {H. B. Curry},
 journal = {American Journal of Mathematics},
 number = {4},
 pages = {789--834},
 publisher = {Johns Hopkins University Press},
 title = {Grundlagen der Kombinatorischen Logik},
 urldate = {2025-11-02},
 volume = {52},
 year = {1930}
}
@article{church_invent_lambda_calc_1932,
 ISSN = {0003486X, 19398980},
 URL = {http://www.jstor.org/stable/1968337},
 author = {Alonzo Church},
 journal = {Annals of Mathematics},
 number = {2},
 pages = {346--366},
 publisher = {[Annals of Mathematics, Trustees of Princeton University on Behalf of the Annals of Mathematics, Mathematics Department, Princeton University]},
 title = {A Set of Postulates for the Foundation of Logic},
 urldate = {2025-11-02},
 volume = {33},
 year = {1932}
}
@article{church_second_paper_1933,
 ISSN = {0003486X},
 URL = {http://www.jstor.org/stable/1968702},
 author = {Alonzo Church},
 journal = {Annals of Mathematics},
 number = {4},
 pages = {839--864},
 publisher = {Annals of Mathematics},
 title = {A Set of Postulates For the Foundation of Logic},
 urldate = {2025-11-02},
 volume = {34},
 year = {1933}
}
@article{turing_computable_1936,
  title={On computable numbers, with an application to the Entscheidungsproblem},
  author={Turing, Alan Mathison and others},
  journal={J. of Math},
  volume={58},
  number={345-363},
  pages={5},
  year={1936},
  publisher={Wiley Online Library}
}
@article{landin_algol_lambda_1965,
author = {Landin, P. J.},
title = {Correspondence between ALGOL 60 and Church's Lambda-notation: part I},
year = {1965},
issue_date = {Feb. 1965},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {2},
issn = {0001-0782},
url = {https://doi.org/10.1145/363744.363749},
doi = {10.1145/363744.363749},
journal = {Commun. ACM},
month = feb,
pages = {89–101},
numpages = {13}
}
@article{landin_my_years_w_strachey_2000,
  title={My years with Strachey},
  author={Landin, Peter J},
  journal={Higher-Order and Symbolic Computation},
  volume={13},
  number={1},
  pages={75--76},
  year={2000},
  publisher={Springer}
}
@article{scott_strachey_math_semantics_for_computer_languages_1971,
author = {Scott, Dana and Strachey, C.},
year = {1971},
month = {01},
pages = {},
title = {Towards a Mathematical Semantics for Computer Languages},
volume = {21},
journal = {Proceedings of the Symposium on Computers and Automata}
}
@inproceedings{evans_pal_language_designed_for_teaching_programming_linguistics_1968,
author = {Evans, Arthur},
title = {PAL—a language designed for teaching programming linguistics},
year = {1968},
isbn = {9781450374866},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800186.810604},
doi = {10.1145/800186.810604},
abstract = {This paper describes PAL—a new computer language. Given the fact that new languages seem to appear in computer literature at the rate of several per month, it seems incumbent on one who creates a new language to justify having done so. In the present case, there are two important considerations: control and specification. Let us consider each of these in turn.By virtue of our having designed PAL, it is ours. There is no PAL Users Group or Committee of Vested Interests concerned with retaining upward compatibility with what was done last year (or last month). This doesn't mean we change the specifications of the language every few weeks (our students are, in a real sense, our Committee of Vested Interests), but it does mean we can make decisions on changes solely on technical grounds. More important, though, we can design the language to meet the criteria we think important. For example, the language almost demands interpretive execution. Since no one writes production programs in PAL we are able to put up with inefficiencies in the implementation that would otherwise be intolerable. Thus we have designed our own language so that we will have control over it.},
booktitle = {Proceedings of the 1968 23rd ACM National Conference},
pages = {395–403},
numpages = {9},
series = {ACM '68}
}
@inproceedings{10.1145/800235.807067,
author = {Milner, Robin},
title = {Implementation and applications of Scott's logic for computable functions},
year = {1972},
isbn = {9781450378918},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/800235.807067},
doi = {10.1145/800235.807067},
abstract = {The basis for this paper is a logic designed by Dana Scott [1] in 1969 for formalizing arguments about computable functions of higher type. This logic uses typed combinators, and we give a more or less direct translation into typed λ-calculus, which is an easier formalism to use, though not so easy for the metatheory because of the presence of bound variables. We then describe, by example only, a proof-checker program which has been implemented for this logic; the program is fully described in [2]. We relate the induction rule which is central to the logic to two more familiar rules - Recursion Induction and Structural Induction - showing that the former is a theorem of the logic, and that for recursively defined structures the latter is a derived rule of the logic. Finally we show how the syntax and semantics of a simple programming language may be described completely in the logic, and we give an example of a theorem which relates syntactic and semantic properties of programs and which can be stated and proved within the logic.},
booktitle = {Proceedings of ACM Conference on Proving Assertions about Programs},
pages = {1–6},
numpages = {6},
location = {Las Cruces, New Mexico, USA}
}

@article{10.1145/942578.807067,
author = {Milner, Robin},
title = {Implementation and applications of Scott's logic for computable functions},
year = {1972},
issue_date = {January 1972},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/942578.807067},
doi = {10.1145/942578.807067},
abstract = {The basis for this paper is a logic designed by Dana Scott [1] in 1969 for formalizing arguments about computable functions of higher type. This logic uses typed combinators, and we give a more or less direct translation into typed λ-calculus, which is an easier formalism to use, though not so easy for the metatheory because of the presence of bound variables. We then describe, by example only, a proof-checker program which has been implemented for this logic; the program is fully described in [2]. We relate the induction rule which is central to the logic to two more familiar rules - Recursion Induction and Structural Induction - showing that the former is a theorem of the logic, and that for recursively defined structures the latter is a derived rule of the logic. Finally we show how the syntax and semantics of a simple programming language may be described completely in the logic, and we give an example of a theorem which relates syntactic and semantic properties of programs and which can be stated and proved within the logic.},
journal = {SIGPLAN Not.},
month = jan,
pages = {1–6},
numpages = {6}
}
@article{milner_implementation_of_lcf_1972,
author = {Milner, Robin},
title = {Implementation and applications of Scott's logic for computable functions},
year = {1972},
issue_date = {January 1972},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
number = {14},
issn = {0163-5700},
url = {https://doi.org/10.1145/942580.807067},
doi = {10.1145/942580.807067},
abstract = {The basis for this paper is a logic designed by Dana Scott [1] in 1969 for formalizing arguments about computable functions of higher type. This logic uses typed combinators, and we give a more or less direct translation into typed λ-calculus, which is an easier formalism to use, though not so easy for the metatheory because of the presence of bound variables. We then describe, by example only, a proof-checker program which has been implemented for this logic; the program is fully described in [2]. We relate the induction rule which is central to the logic to two more familiar rules - Recursion Induction and Structural Induction - showing that the former is a theorem of the logic, and that for recursively defined structures the latter is a derived rule of the logic. Finally we show how the syntax and semantics of a simple programming language may be described completely in the logic, and we give an example of a theorem which relates syntactic and semantic properties of programs and which can be stated and proved within the logic.},
journal = {SIGACT News},
month = jan,
pages = {1–6},
numpages = {6}
}
@article{scott_type_theory_iswim_cuch_1969,
  title={A type-theoretical alternative to ISWIM, CUCH, OWHY},
  author={Scott, Dana S},
  journal={Theoretical computer science},
  volume={121},
  number={1-2},
  pages={411--440},
  year={1993},
  publisher={Elsevier},
  origdate={1969}
}
@book{plotkin_history_of_robin_milner_2000,
    author = {Plotkin, Gordon and Stirling, Colin P. and Tofte, Mads},
    title = {Proof, Language, and Interaction: Essays in Honour of Robin Milner},
    publisher = {The MIT Press},
    year = {2000},
    month = {05},
    abstract = {This collection of original essays reflects the breadth of current research in computer science.This collection of original essays reflects the breadth of current research in computer science. Robin Milner, a major figure in the field, has made many fundamental contributions, particularly in theoretical computer science, the theory of programming languages, and functional programming languages. Following a brief biography of Milner, the book contains five sections: Semantic Foundations, Programming Logic, Programming Languages, Concurrency, and Mobility. Together the pieces convey a seamless whole, ranging from highly abstract concepts to systems of great utility.ContributorsSamson Abramsky, J. C. M. Baeten, Sergey Berezin, J. A. Bergstra, Gérard Berry, Lars Birkedal, Gérard Boudol, Edmund Clarke, Pierre Collette, Robert L. Constable, Pierre-Louis Curien, Jaco de Bakker, Uffe H. Engberg, William Ferreira, Fabio Gadducci, Mike Gordon, Robert Harper, Matthew Hennessy, Yoram Hirshfeld, C. A. R. Hoare, Gérard Huet, Paul B. Jackson, Alan S. A. Jeffrey, Somesh Jha, He Jifeng, Cliff B. Jones, Cosimo Laneve, Xinxin Liu, Will Marrero, Faron Moller, Ugo Montanari, Pavel Naumov, Mogens Nielsen, Joachim Parrow, Lawrence C. Paulson, Benjamin C. Pierce, Gordon Plotkin, M. A. Reniers, Amokrane Saïbi, Augusto Sampaio, Davide Sangiorgi, Scott A. Smolka, Eugene W. Stark, Christopher Stone, Mads Tofte, David N. Turner, Juan Uribe, Franck van Breugel, David Walker, Glynn Winskel},
    isbn = {9780262281676},
    doi = {10.7551/mitpress/5641.001.0001},
    url = {https://doi.org/10.7551/mitpress/5641.001.0001},
}
@online{macqueen_history_lcf_ml_2025,
  author       = {David MacQueen},
  title        = {The History of LCF, ML and HOPE},
  series       = {Type Theory Forall},
  number       = {47},
  date         = {2025-01-07},
  url          = {https://www.typetheoryforall.com/episodes/the-history-of-lcf-ml-and-hope},
  duration     = {125\,min},
  note         = {Podcast episode}
}
@article{strachey_fundamental_concepts_2000,
author = {Strachey, Christopher},
title = {Fundamental Concepts in Programming Languages},
year = {2000},
issue_date = {April 2000},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {13},
number = {1–2},
issn = {1388-3690},
url = {https://doi.org/10.1023/A:1010000313106},
doi = {10.1023/A:1010000313106},
abstract = {This paper forms the substance of a course of lectures given at the International Summer School in Computer Programming at Copenhagen in August, 1967. The lectures were originally given from notes and the paper was written after the course was finished. In spite of this, and only partly because of the shortage of time, the paper still retains many of the shortcomings of a lecture course. The chief of these are an uncertainty of aim—it is never quite clear what sort of audience there will be for such lectures—and an associated switching from formal to informal modes of presentation which may well be less acceptable in print than it is natural in the lecture room. For these (and other) faults, I apologise to the reader.There are numerous references throughout the course  to CPL [1–3]. This is a programming language which has been under development since 1962 at Cambridge and London and Oxford. It has served as a vehicle for research into both programming languages and the design of compilers. Partial implementations exist at Cambridge and London. The language is still evolving so that there is no definitive manual available yet. We hope to reach another resting point in its evolution quite soon and to produce a compiler and reference manuals for this version. The compiler will probably be written in such a way that it is relatively easyto transfer it to another machine, and in the first instance we hope to establish it on three or four machines more or less at the same time.The lack of a precise formulation for CPL should not cause much difficulty in this course, as we are primarily concerned with the ideas and concepts involved rather than with their precise representation in a programming language.},
journal = {Higher Order Symbol. Comput.},
month = apr,
pages = {11–49},
numpages = {39},
keywords = {CPL, L-values, R-values, ad hoc polymorphism, binding mechanisms, foundations of computing, functions as data, parameter passing, parametric polymorphism, programming languages, semantics, type completeness, variable binding}
}
@article{richards_strachey_and_cpl_compiler_2000,
author = {Richards, Martin},
title = {Christopher Strachey and the Cambridge CPL Compiler},
year = {2000},
issue_date = {April 2000},
publisher = {Kluwer Academic Publishers},
address = {USA},
volume = {13},
number = {1–2},
issn = {1388-3690},
url = {https://doi.org/10.1023/A:1010014110806},
doi = {10.1023/A:1010014110806},
journal = {Higher Order Symbol. Comput.},
month = apr,
pages = {85–88},
numpages = {4}
}
@article{barron_strachey_main_features_of_cpl_1963,
    author = {Barron, D. W. and Buxton, J. N. and Hartley, D. F. and Nixon, E. and Strachey, C.},
    title = {The Main Features of CPL},
    journal = {The Computer Journal},
    volume = {6},
    number = {2},
    pages = {134-143},
    year = {1963},
    month = {08},
    abstract = {The paper provides an informal account of CPL, a new programming language currently being implemented for the Titan at Cambridge and the Atlas at London University. CPL is based on, and contains the concepts of, ALGOL 60. In addition there are extended data descriptions, command and expression structures, provision for manipulating non-numerical objects, and comprehensive input-output facilities. However, CPL is not just another proposal for the extension of ALGOL 60, but has been designed from first principles and has a logically coherent structure.},
    issn = {0010-4620},
    doi = {10.1093/comjnl/6.2.134},
    url = {https://doi.org/10.1093/comjnl/6.2.134},
    url2 = {https://scispace.com/pdf/the-main-features-of-cpl-4zi1wv2qhe.pdf},
    eprint = {https://academic.oup.com/comjnl/article-pdf/6/2/134/1041447/6-2-134.pdf},
}
@online{inria_history_of_ocaml_2019,
  author       = {{INRIA}},
  title        = {A History of {OCaml}},
  year         = {2019},
  url          = {https://ocaml.org/learn/history.html},
  urldate      = {2019-11-06},
  archiveurl   = {https://web.archive.org/web/20200118031918/https://ocaml.org/learn/history.html},
  archivedate  = {2020-01-18T03:19:18},
}
@online{orosz_lattner_pragmatic_engineer_podcast_swift_2025,
  author   = {Gergely Orosz},
  title    = {From Swift to Mojo and high-performance AI Engineering with Chris Lattner},
  series   = {The Pragmatic Engineer},
  date     = {2025-11-05},
  url      = {https://newsletter.pragmaticengineer.com/p/from-swift-to-mojo-and-high-performance},
  note     = {Podcast episode; duration 1h 32m.}
}
@PhdThesis{lattner_phd_thesis_pointer_intensive_programs_2005,
  author  = {Chris Lattner},
  title   = "{Macroscopic Data Structure Analysis and Optimization}",
  school  = "{Computer Science Dept., University of Illinois at Urbana-Champaign}",
  year    = {2005},
  address = {Urbana, IL},
  month   = {May},
  note    = {{\em See {\tt http://llvm.cs.uiuc.edu}.}},
  url={https://hdl.handle.net/2142/10994}
}
@misc{lattner_resume_work_history_2025,
  author       = {Chris Lattner},
  title        = {Chris Lattner's Resumé and Work History},
  year         = {2025},
  note         = {Last updated June 2025},
  howpublished = {\url{https://www.nondot.org/sabre/Resume.html}},
  url          = {https://www.nondot.org/sabre/Resume.html},
  institution  = {Modular AI},
  keywords     = {career, resume, compiler, LLVM, Clang, Swift, MLIR, CIRCT, Apple, Tesla, Google, SiFive, Modular AI},
}
@misc{lattner_minsky_why_ml_needs_new_programming_language_2025,
  author       = {Chris Lattner and Ron Minsky},
  title        = {Why ML Needs a New Programming Language},
  date         = {2025-09-03},
  howpublished = {\url{https://signalsandthreads.com/why-ml-needs-a-new-programming-language/}},
  note         = {Podcast interview on Signals and Threads, Jane Street},
  url          = {https://signalsandthreads.com/why-ml-needs-a-new-programming-language/},
  keywords     = {Mojo, programming language, AI, interview, Chris Lattner, Jane Street, podcast, machine learning},
}
@misc{lattner_golden_age_compiler_design_2021,
  author       = {Chris Lattner},
  title        = {The Golden Age of Compiler Design in an Era of HW/SW Co-design},
  year         = {2021},
  howpublished = {Keynote presented at ASPLOS 2021, April 20, 2021. Available at \url{https://youtu.be/4HgShra-KnY?si=yh2LZdeUpnPNCv-p}},
  note         = {ASPLOS 2021 Keynote, 48{,}383 views as of Apr 20, 2021},
  url          = {https://youtu.be/4HgShra-KnY?si=yh2LZdeUpnPNCv-p},
  organization = {ASPLOS 2021 Conference},
  keywords     = {compilers, hardware/software co-design, keynote, ASPLOS, LLVM, Chris Lattner}
}
@book{appel_modern_compiler_impl_in_ml_1997,
author = {Appel, Andrew W.},
title = {Modern Compiler Implementation in ML: Basic Techniques},
year = {1997},
isbn = {052158275X},
publisher = {Cambridge University Press},
address = {USA},
abstract = {From the Publisher:This textbook describes all phases of a modern compiler. It includes good coverage of current techniques in code generation and register allocation, as well as functional and object-oriented languages, that is missing from most books. In a concise way, the author describes the most accepted and successful techniques, rather than giving an exhaustive catalog of every possible variant. Detailed descriptions of the interfaces between modules of a compiler are illustrated with actual ML signatures. A unique feature of the book is a well designed compiler implementation project in ML, including front-end and high-tech back-end phases, useful for undergraduate and graduate students as well as computer professionals needing a reference on compiler implementation.}
}
@book{ullman_principles_of_ml_programming_1998,
author = {Ullman, Jeffrey D.},
title = {Elements of ML programming (ML97 ed.)},
year = {1998},
isbn = {0137903871},
publisher = {Prentice-Hall, Inc.},
address = {USA}
}
@inbook{stallman_gnu_manifesto_1990,
author = {Stallman, Richard M.},
title = {The GNU manifesto},
year = {1990},
isbn = {019505850X},
publisher = {Oxford University Press, Inc.},
address = {USA},
booktitle = {Computers, Ethics, \& Society},
pages = {308–317},
numpages = {10}
}
@misc{stallman_biographies_2025,
  author       = {Stallman, Richard M.},
  title        = {Biographies},
  howpublished = {\url{https://stallman.org/biographies.html}},
  note         = {Accessed: 2025-11-08},
  year         = {n.d.}
}
@online{gross_stallman_interview_1999,
  author    = {Gross, Michael},
  title     = {Richard Stallman: High School Misfit, Symbol of Free Software, MacArthur-Certified Genius},
  year      = {1999},
  subtitle  = {Interview transcript in *The More Things Change*},
  url       = {https://www.mgross.com/books/my-generation/my-generation-bonus-chapters/richard-stallman-high-school-misfit-symbol-of-free-software-macarthur-certified-genius/},
  urldate   = {2014-04-09}
}
@online{stallman_my_lisp_experiences_2002,
  author    = {Stallman, Richard},
  title     = {My Lisp Experiences and the Development of {GNU} Emacs},
  year      = {2002},
  note      = {Transcript of Richard Stallman's speech at the International Lisp Conference, 28 Oct 2002},
  url       = {https://www.gnu.org/gnu/rms-lisp.html},
  urldate   = {2025-11-08}
}
@online{weinreb_symbolics_history_2020,
  author    = {Weinreb, Dan},
  title     = {History of Symbolics Lisp Machines: Rebuttal to Stallman’s Story About the Formation of Symbolics and LMI},
  year      = {2020},
  note      = {Archive of Dan Weinreb's comments on Symbolics and Lisp machines},
  url       = {https://danluu.com/symbolics-lisp-machines/},
  urldate   = {2025-11-08}
}
@book{salus_reed_daemon_gnu_penguin_2008,
author = {Salus, Peter H. and Reed, Jeremy C.},
title = {The Daemon, the Gnu, and the Penguin},
year = {2008},
isbn = {097903423X},
url={https://web.archive.org/web/20220620020435/http://www.groklaw.net/article.php?story=20050525231654621},
publisher = {Reed Media Services},
abstract = {In addition to covering a history of free and open source, The Daemon, the Gnu, and the Penguin explores how free and open software is changing the world. It is authored by Peter H. Salus, a noted UNIX, open source, and Internet historian and author of A Quarter Century of UNIX and Casting The Net and other books. Salus has interviewed well over a hundred key figures to document the history and background of free and open source software. In his book, Salus reaches back into the early days of computing, showing that even in "pre-UNIX" days there was freely available software, and rapidly moves forward to the Free Software movement of today and what it means for the future, drawing analogies and linkages from various aspects of economics and life.}
}
@book{von_hagen_definitive_guide_gcc_2011,
  title={The definitive guide to GCC},
  author={Von Hagen, William},
  year={2011},
  publisher={Apress},
  url={https://sensperiodit.wordpress.com/wp-content/uploads/2011/04/hagen-the-definitive-guide-to-gcc-2e-apress-2006.pdf},
}
