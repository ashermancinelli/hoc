% Wikipedia has been a useful collection of primary and secondary sources
% https://en.wikipedia.org/wiki/History_of_compiler_construction#cite_ref-8
% https://en.wikipedia.org/wiki/History_of_programming_languages
% https://en.wikipedia.org/wiki/Timeline_of_programming_languages
% author = {Haigh, Thomas and Ceruzzi, Paul E.},
@book{new-history-of-modern-computing,
  address      = {Cambridge [Massachusetts]},
  series       = {History of Computing},
  title        = {A New History of Modern Computing},
  isbn         = {9780262542906},
  abstract     = {"Bringing the history of modern computing fully up to date, from new applications to scientific computation to video games and the ubiquitous smartphone"},
  language     = {eng},
  publisher    = {The MIT Press},
  author       = {Haigh, Thomas},
  year         = {2021}
}
@misc{did_grace_hopper_create_the_first_compiler_2022,
  title        = {Did {Grace} {Hopper} {Create} the {First} {Compiler}? {Communications} of the {ACM}},
  shorttitle   = {Did {Grace} {Hopper} {Create} the {First} {Compiler}?},
  url          = {https://cacm.acm.org/blogcacm/did-grace-hopper-create-the-first-compiler/},
  language     = {en-US},
  urldate      = {2025-10-04},
  month        = dec,
  year         = {2022},
  author       = {Bruderer, Herbert}
}
@book{kernighan_unix:_2020,
  address      = {s. l.},
  title        = {{UNIX}: a history and a memoir},
  isbn         = {9781695978553},
  shorttitle   = {{UNIX}},
  language     = {eng},
  publisher    = {Kindle Direct Publishing},
  author       = {Kernighan, Brian W.},
  year         = {2020}
}
@inproceedings{bauer_software_1968,
  address      = {Garmisch, Germany},
  title        = {SOFTWARE ENGINEERING},
  booktitle    = {SOFTWARE ENGINEERING},
  url          = {https://www.scrummanager.com/files/nato1968e.pdf},
  publisher    = {NATO SCIENCE COMMITTEE},
  author       = {Bauer, Friedrick and Naur, Peter and Randell, Brian},
  month        = oct,
  year         = {1968}
}
@misc{numba_cuda,
  author       = {{NVIDIA Corporation}},
  title        = {Numba CUDA},
  shorttitle   = {Numba CUDA},
  year         = {2024},
  publisher    = {GitHub},
  howpublished = {\url{https://github.com/NVIDIA/numba-cuda/}},
  urldate      = {2025-10-04},
  note         = {The CUDA target for Numba}
}
@misc{jax-compiler,
  author       = {JAX Authors},
  howpublished = {\url{https://github.com/jax-ml/jax}},
  title        = {JAX: High performance array computing},
  year         = {2024}
}
@inproceedings{lam-numba,
  address      = {Austin Texas},
  title        = {Numba: a {LLVM}-based {Python} {JIT} compiler},
  isbn         = {9781450340052},
  shorttitle   = {Numba},
  url          = {https://dl.acm.org/doi/10.1145/2833157.2833162},
  doi          = {10.1145/2833157.2833162},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Proceedings of the {Second} {Workshop} on the {LLVM} {Compiler} {Infrastructure} in {HPC}},
  publisher    = {ACM},
  author       = {Lam, Siu Kwan and Pitrou, Antoine and Seibert, Stanley},
  month        = nov,
  year         = {2015},
  pages        = {1--6}
}
@inproceedings{triton-tillet,
  address      = {Phoenix AZ USA},
  title        = {Triton: an intermediate language and compiler for tiled neural network computations},
  isbn         = {9781450367196},
  shorttitle   = {Triton},
  url          = {https://dl.acm.org/doi/10.1145/3315508.3329973},
  doi          = {10.1145/3315508.3329973},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Proceedings of the 3rd {ACM} {SIGPLAN} {International} {Workshop} on {Machine} {Learning} and {Programming} {Languages}},
  publisher    = {ACM},
  author       = {Tillet, Philippe and Kung, H. T. and Cox, David},
  month        = jun,
  year         = {2019},
  pages        = {10--19}
}
@inproceedings{llvm,
  author       = {Lattner, Chris and Adve, Vikram},
  title        = {LLVM: A Compilation Framework for Lifelong Program Analysis \& Transformation},
  year         = {2004},
  isbn         = {0769521029},
  publisher    = {IEEE Computer Society},
  address      = {USA},
  abstract     = {This paper describes LLVM (Low Level Virtual Machine),a compiler framework designed to support transparent, lifelongprogram analysis and transformation for arbitrary programs,by providing high-level information to compilertransformations at compile-time, link-time, run-time, and inidle time between runs.LLVM defines a common, low-levelcode representation in Static Single Assignment (SSA) form,with several novel features: a simple, language-independenttype-system that exposes the primitives commonly used toimplement high-level language features; an instruction fortyped address arithmetic; and a simple mechanism that canbe used to implement the exception handling features ofhigh-level languages (and setjmp/longjmp in C) uniformlyand efficiently.The LLVM compiler framework and coderepresentation together provide a combination of key capabilitiesthat are important for practical, lifelong analysis andtransformation of programs.To our knowledge, no existingcompilation approach provides all these capabilities.We describethe design of the LLVM representation and compilerframework, and evaluate the design in three ways: (a) thesize and effectiveness of the representation, including thetype information it provides; (b) compiler performance forseveral interprocedural problems; and (c) illustrative examplesof the benefits LLVM provides for several challengingcompiler problems.},
  booktitle    = {Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization},
  pages        = {75},
  location     = {Palo Alto, California},
  series       = {CGO '04}
}
@inproceedings{mlir,
  author       = {Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},
  booktitle    = {2021 IEEE/ACM International Symposium on Code Generation and Optimization (CGO)},
  title        = {MLIR: Scaling Compiler Infrastructure for Domain Specific Computation},
  year         = {2021},
  volume       = {},
  number       = {},
  pages        = {2--14},
  keywords     = {Program processors;Buildings;Semantics;Hardware;Software;Generators;Optimization},
  doi          = {10.1109/CGO51591.2021.9370308}
}
@inbook{hopl_backus_history_of_fortran,
  author       = {Backus, John},
  title        = {The history of Fortran I, II, and III},
  year         = {1978},
  isbn         = {0127450408},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://www.cs.toronto.edu/~bor/199y08/backus-fortran-copy.pdf},
  booktitle    = {History of Programming Languages},
  pages        = {25--74},
  numpages     = {50}
}
@inbook{hopl_keynote,
  author       = {Hopper, Grace},
  title        = {Keynote Address},
  year         = {1978},
  isbn         = {0127450408},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://dl.acm.org/doi/pdf/10.1145/800025.1198341},
  booktitle    = {History of Programming Languages},
  pages        = {25--74},
  numpages     = {50}
}
@inproceedings{rosen_altac_fortran_1961,
  author       = {Rosen, Saul},
  title        = {ALTAC, FORTRAN, and compatibility},
  year         = {1961},
  isbn         = {9781450373883},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/800029.808498},
  doi          = {10.1145/800029.808498},
  abstract     = {One of the major aims in the development of universal or common problem-oriented languages has been to permit a user to make the transition from one computer to another without the necessity of a complete reprogramming job.The ALTAC compiler, compatible with FORTRAN II, has been used to implement such a transition from the IBM 704 to the PHILCO 2000 at a number of installations. To the best of my knowledge this is the first time that a compiler has assumed the major burden of transition from a large scale computer of one manufacturer to an even larger scale computer of another manufacturer.},
  booktitle    = {Proceedings of the 1961 16th ACM National Meeting},
  pages        = {22.201--22.204},
  series       = {ACM '61}
}
@misc{noauthor_biography_nodate,
  title        = {Biography of {Grace} {Murray} {Hopper} {\textbar} {Office} of the {President}},
  url          = {https://president.yale.edu/biography-grace-murray-hopper},
  language     = {en},
  urldate      = {2025-10-04},
  year         = {2025}
}
@article{bellia_hierarchical_1981,
  title        = {Hierarchical development of programming languages},
  volume       = {18},
  copyright    = {http://www.springer.com/tdm},
  issn         = {0008-0624, 1126-5434},
  url          = {http://link.springer.com/10.1007/BF02576358},
  doi          = {10.1007/BF02576358},
  language     = {en},
  number       = {3},
  urldate      = {2025-10-04},
  journal      = {Calcolo},
  author       = {Bellia, M.},
  month        = sep,
  year         = {1981},
  pages        = {219--254}
}
@book{bentley_digitized:_2012,
  address      = {Oxford},
  title        = {Digitized: the science of computers and how it shapes our world},
  isbn         = {9780199693795},
  shorttitle   = {Digitized},
  abstract     = {In this book the author tells the story of computer science, explaining how and why computers were invented, how they work, looking at real-world examples of computers in use, and considering what will happen in the future. There's a hidden science that affects every part of your life. You are fluent in its terminology of email, WiFi, social networking, and encryption. You use its results when you make a telephone call, access the Internet, use any factory-produced product, or travel in any modern car. The discipline is so new that some prefer to call it a branch of engineering or mathematics. But it is so powerful and world-changing that you would be hard-pressed to find a single human being on the planet unaffected by its achievements. The science of computers enables the supply and creation of power, food, water, medicine, transport, money, communication, entertainment, and most goods in shops. It has transformed societies with the Internet, the digitization of information, mobile phone networks and GPS (Global Positioning System) technologies. Here, the author explores how this young discipline grew from its theoretical conception by pioneers such as Turing, through its growth spurts in the Internet, its difficult adolescent stage where the promises of Artificial Intelligence (AI) were never achieved and dot-com bubble burst, to its current stage as a (semi)mature field, now capable of remarkable achievements. Charting the successes and failures of computer science through the years, he discusses what innovations may change our world in the future},
  language     = {eng},
  publisher    = {Oxford university press},
  author       = {Bentley, Peter J.},
  year         = {2012}
}
@article{10.1145/99164.99179,
  author       = {Whitfield, D. and Soffa, M. L.},
  title        = {An approach to ordering optimizing transformations},
  year         = {1990},
  issue_date   = {Mar. 1990},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {25},
  number       = {3},
  issn         = {0362-1340},
  url          = {https://doi.org/10.1145/99164.99179},
  doi          = {10.1145/99164.99179},
  abstract     = {As an approach to deriving an application order of optimizing transformations, a framework is developed for examining the interactions of the transformations. The framework is based on an axiomatic specification technique and includes both pre-conditions and post conditions that must exist before and after applying optimizations. For a selected set of optimizations, the framework is used to determine those interactions among the optimizations that can create conditions and those that can destroy conditions for applying other optimizations. From these interactions, an application order is derived to obtain the potential benefits of the optimizations that can be applied to a program. In some cases, the ordering of a pair of optimizations is unambiguous in that one optimization can either create or destroy the conditions for the other. In the few cases where there is a cyclic interaction, the ordering is resolved based on the perceived importance of the two optimizations.},
  journal      = {SIGPLAN Not.},
  month        = feb,
  pages        = {137--146},
  numpages     = {10}
}
@article{bacon_compiler_1994,
  author       = {Bacon, David F. and Graham, Susan L. and Sharp, Oliver J.},
  title        = {Compiler transformations for high-performance computing},
  year         = {1994},
  issue_date   = {Dec. 1994},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {26},
  number       = {4},
  issn         = {0360-0300},
  url          = {https://doi.org/10.1145/197405.197406},
  doi          = {10.1145/197405.197406},
  abstract     = {In the last three decades a large number of compiler transformations for optimizing programs have been implemented. Most optimizations for uniprocessors reduce the number of instructions executed by the program using transformations based on the analysis of scalar quantities and data-flow techniques. In contrast, optimizations for high-performance superscalar, vector, and parallel processors maximize parallelism and memory locality with transformations that rely on tracking the properties of arrays using loop dependence analysis.This survey is a comprehensive overview of the important high-level program restructuring techniques for imperative languages, such as C and Fortran. Transformations for both sequential and various types of parallel architectures are covered in depth. We describe the purpose of each transformation, explain how to determine if it is legal, and give an example of its application.Programmers wishing to enhance the performance of their code can use this survey to improve their understanding of the optimizations that compilers can perform, or as a reference for techniques to be applied manually. Students can obtain an overview of optimizing compiler technology. Compiler writers can use this survey as a reference for most of the important optimizations developed to date, and as bibliographic reference for the details of each optimization. Readers are expected to be familiar with modern computer architecture and basic program compilation techniques.},
  journal      = {ACM Comput. Surv.},
  month        = dec,
  pages        = {345--420},
  numpages     = {76},
  keywords     = {vectorization, superscalar processors, parallelism, optimization, multiprocessors, locality, dependence analysis, compilation}
}
@misc{henry_comp.compilers:_nodate,
  title        = {Comp.compilers: {Re}: {History} and evolution of compilers},
  url          = {https://compilers.iecc.com/comparch/article/97-10-017},
  abstract     = {From comp.compilers newsgroup: Re: History and evolution of compilers},
  urldate      = {2025-10-04},
  author       = {Henry, Spencer},
  year         = {1997}
}
@misc{norman_grace_nodate,
  title        = {Grace {Hopper} and {Colleagues} {Introduce} {COBOL}},
  url          = {https://www.historyofinformation.com/detail.php?id=778},
  author       = {Norman, Jeremy},
  year         = {1959}
}
@book{laplante_encyclopedia_2017,
  address      = {BOCA RATON},
  edition      = {Second edition.},
  title        = {Encyclopedia of computer science and technology. {Volume} {II}, {Fuzzy}-{XML}},
  isbn         = {9781315115887},
  abstract     = {This book covers all aspects of computer science, engineering, and technology. It includes computer scientists, computer engineers computing professionals, managers, software professionals, and other technology professionals.},
  language     = {eng},
  publisher    = {CRC Press},
  author       = {Laplante, Phillip A.},
  year         = {2017},
  note         = {OCLC: 1032027866},
  keywords     = {Information technology Encyclopedias, Computer science Encyclopedias}
}
@article{landin_next_1966,
  title        = {The next 700 programming languages},
  volume       = {9},
  issn         = {0001-0782, 1557-7317},
  url          = {https://dl.acm.org/doi/10.1145/365230.365257},
  doi          = {10.1145/365230.365257},
  abstract     = {A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, list of them, functional relations among them) that can be referred to in the language.            The system is biased towards "expressions" rather than "statements." It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand.},
  language     = {en},
  number       = {3},
  urldate      = {2025-10-04},
  journal      = {Communications of the ACM},
  author       = {Landin, P. J.},
  month        = mar,
  year         = {1966},
  pages        = {157--166}
}
@article{10.1145/321992.322001,
  author       = {Aho, A. V. and Johnson, S. C. and Ullman, J. D.},
  title        = {Code Generation for Expressions with Common Subexpressions},
  year         = {1977},
  issue_date   = {Jan. 1977},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {24},
  number       = {1},
  issn         = {0004-5411},
  url          = {https://doi.org/10.1145/321992.322001},
  doi          = {10.1145/321992.322001},
  abstract     = {This paper shows the problem of generating optimal code for expressions containing common subexpressions is computationally difficult, even for simple expressions and simple machines. Some heuristics for code generation are given and their worst-case behavior is analyzed. For one register machines, an optimal code generation algorithm is given whose time complexity is linear in the size of an expression and exponential only in the amount of sharing.},
  journal      = {J. ACM},
  month        = jan,
  pages        = {146--160},
  numpages     = {15}
}
@book{10.5555/6448,
  author       = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  title        = {Compilers: principles, techniques, and tools},
  year         = {1986},
  isbn         = {0201100886},
  publisher    = {Addison-Wesley Longman Publishing Co., Inc.},
  address      = {USA}
}
@article{10.1145/29873.29875,
  author       = {Allen, Randy and Kennedy, Ken},
  title        = {Automatic translation of FORTRAN programs to vector form},
  year         = {1987},
  issue_date   = {Oct. 1987},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {9},
  number       = {4},
  issn         = {0164-0925},
  url          = {https://doi.org/10.1145/29873.29875},
  doi          = {10.1145/29873.29875},
  abstract     = {The recent success of vector computers such as the Cray-1 and array processors such as those manufactured by Floating Point Systems has increased interest in making vector operations available to the FORTRAN programmer. The FORTRAN standards committee is currently considering a successor to FORTRAN 77, usually called FORTRAN 8x, that will permit the programmer to explicitly specify vector and array operations.Although FORTRAN 8x will make it convenient to specify explicit vector operations in new programs, it does little for existing code. In order to benefit from the power of vector hardware, existing programs will need to be rewritten in some language (presumably FORTRAN 8x) that permits the explicit specification of vector operations. One way to avoid a massive manual recoding effort is to provide a translator that discovers the parallelism implicit in a FORTRAN program and automatically rewrites that program in FORTRAN 8x.Such a translation from FORTRAN to FORTRAN 8x is not straightforward because FORTRAN DO loops are not always semantically equivalent to the corresponding FORTRAN 8x parallel operation. The semantic difference between these two constructs is precisely captured by the concept of dependence. A translation from FORTRAN to FORTRAN 8x preserves the semantics of the original program if it preserves the dependences in that program.The theoretical background is developed here for employing data dependence to convert FORTRAN programs to parallel form. Dependence is defined and characterized in terms of the conditions that give rise to it; accurate tests to determine dependence are presented; and transformations that use dependence to uncover additional parallelism are discussed.},
  journal      = {ACM Trans. Program. Lang. Syst.},
  month        = oct,
  pages        = {491--542},
  numpages     = {52}
}
@book{10.5555/1097042,
  author       = {Cocke, John},
  title        = {Programming languages and their compilers: Preliminary notes},
  year         = {1969},
  isbn         = {B0007F4UOA},
  publisher    = {New York University},
  address      = {USA}
}
@techreport{allen_catalogue_1971,
  title        = {A {Catalogue} of {Optimizing} {Transformations}},
  url          = {https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf},
  institution  = {IBM J Watson Research Center},
  author       = {Allen, Francis and Cocke, John},
  year         = {1971}
}
@inproceedings{backus_fortran_1957,
  address      = {Los Angeles, California},
  title        = {The {FORTRAN} automatic coding system},
  copyright    = {https://www.acm.org/publications/policies/copyright\_policy\#Background},
  url          = {http://portal.acm.org/citation.cfm?doid=1455567.1455599},
  doi          = {10.1145/1455567.1455599},
  language     = {en},
  urldate      = {2025-10-04},
  booktitle    = {Papers presented at the {February} 26-28, 1957, western joint computer conference: {Techniques} for reliability on - {IRE}-{AIEE}-{ACM} '57 ({Western})},
  publisher    = {ACM Press},
  author       = {Backus, J. W. and Stern, H. and Ziller, I. and Hughes, R. A. and Nutt, R. and Beeber, R. J. and Best, S. and Goldberg, R. and Haibt, L. M. and Herrick, H. L. and Nelson, R. A. and Sayre, D. and Sheridan, P. B.},
  year         = {1957},
  pages        = {188--198}
}
@book{the-first-computers-2002,
  author       = {Rojas, Raul and Hashagen, Ulf},
  title        = {The  First Computers: History and Architectures},
  year         = {2002},
  isbn         = {0262681374},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  abstract     = {From the Publisher:This history of computing focuses not on chronology (what came first and who deserves credit for it) but on the actual architectures of the first machines that made electronic computing a practical reality. The book covers computers built in the United States, Germany, England, and Japan. It makes clear that similar concepts were often pursued simultaneously and that the early researchers explored many architectures beyond the von Neumann architecture that eventually became canonical. The contributors include not only historians but also engineers and computer pioneers. An introductory chapter describes the elements of computer architecture and explains why "being first" is even less interesting for computers than for other areas of technology. The essays contain a remarkable amount of new material, even on well-known machines, and several describe reconstructions of the historic machines. These investigations are of more than simply historical interest, for architectures designed to solve specific problems in the past may suggest new approaches to similar problems in today's machines.}
}
@inproceedings{architecture-of-konrad-zuses-z4-computer-2021,
  author       = {Rojas, Raúl},
  booktitle    = {2021 7th IEEE History of Electrotechnology Conference (HISTELCON)},
  title        = {The Architecture of Konrad Zuse's Z4 Computer},
  year         = {2021},
  volume       = {},
  number       = {},
  url          = {https://ieeexplore.ieee.org/document/9787324},
  pages        = {43--47},
  keywords     = {Computers;Codes;Terminology;Instruction sets;Computer architecture;Programming;Telephone sets;Konrad Zuse;Versuchsmaschine 4;computer architecture},
  doi          = {10.1109/HISTELCON52394.2021.9787324}
}
@article{10.1145/361454.361515,
  author       = {Bauer, F. L. and W\"{o}ssner, H.},
  title        = {The "Plankalk\"{u}l" of Konrad Zuse: a forerunner of today's programming languages},
  year         = {1972},
  issue_date   = {July 1972},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {15},
  number       = {7},
  issn         = {0001-0782},
  url          = {https://doi.org/10.1145/361454.361515},
  doi          = {10.1145/361454.361515},
  abstract     = {Plankalk\"{u}l was an attempt by Konrad Zuse in the 1940's to devise a notational and conceptual system for writing what today is termed a program. Although this early approach to a programming language did not lead to practical use, the plan is described here because it contains features that are standard in today's programming languages. The investigation is of historical interest; also, it may provide insights that would lead to advancements in the state of the art. Using modern programming terminology, the Plankalk\"{u}l is presented to the extent it has been possible to reconstruct it from the published literature.},
  journal      = {Commun. ACM},
  month        = jul,
  pages        = {678--685},
  numpages     = {8},
  keywords     = {higher programming languages, history of programming, programming, theory of programming}
}
@inbook{konrad-zuses-z4-2000,
  author       = {Speiser, Ambros P.},
  title        = {Konrad Zuse's Z4: architecture, programming, and modifications at the ETH Zurich},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {263--276},
  numpages     = {14}
}
@inbook{notation_as_a_tool_of_thought_2007,
  author       = {Iverson, Kenneth E.},
  title        = {Notation as a tool of thought},
  year         = {2007},
  isbn         = {9781450310499},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/1283920.1283935},
  booktitle    = {ACM Turing Award Lectures},
  pages        = {1979}
}
@article{goldstine_annals_1980,
  title        = {\textit{{Annals} of the {History} of {Computing}} . {Bernard} {A}. {Galler}},
  volume       = {71},
  issn         = {0021-1753, 1545-6994},
  url          = {https://www.journals.uchicago.edu/doi/10.1086/352427},
  doi          = {10.1086/352427},
  language     = {en},
  number       = {1},
  urldate      = {2025-10-05},
  journal      = {Isis},
  author       = {Goldstine, Herman H.},
  month        = mar,
  year         = {1980},
  pages        = {160--160}
}
@inbook{nothing_new_since_von_neumann_2000,
  author       = {Ceruzzi, Paul},
  title        = {"Nothing new since von Neumann": a historian looks at computer architecture, 1945-1995},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {195--217},
  numpages     = {23}
}
@article{can_programming_be_liberated_from_the_von_neumann_style_1978,
  author       = {Backus, John},
  title        = {Can programming be liberated from the von Neumann style? a functional style and its algebra of programs},
  year         = {1978},
  issue_date   = {Aug. 1978},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {21},
  number       = {8},
  issn         = {0001-0782},
  url          = {https://doi.org/10.1145/359576.359579},
  doi          = {10.1145/359576.359579},
  abstract     = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of programming inherited from their common ancestor—the von Neumann computer, their close coupling of semantics to state transitions, their division of programming into a world of expressions and a world of statements, their inability to effectively use powerful combining forms for building new programs from existing ones, and their lack of useful mathematical properties for reasoning about programs.An alternative functional style of programming is founded on the use of combining forms for creating programs. Functional programs deal with structured data, are often nonrepetitive and nonrecursive, are hierarchically constructed, do not name their arguments, and do not require the complex machinery of procedure declarations to become generally applicable. Combining forms can use high level programs to build still higher level ones in a style not possible in conventional languages.Associated with the functional style of programming is an algebra of programs whose variables range over programs and whose operations are combining forms. This algebra can be used to transform programs and to solve equations whose "unknowns" are programs in much the same way one transforms equations in high school algebra. These transformations are given by algebraic laws and are carried out in the same language in which programs are written. Combining forms are chosen not only for their programming power but also for the power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and termination conditions for large classes of programs.A new class of computing systems uses the functional programming style both in its programming language and in its state transition rules. Unlike von Neumann languages, these systems have semantics loosely coupled to states—only one state transition occurs per major computation.},
  journal      = {Commun. ACM},
  month        = aug,
  pages        = {613--641},
  numpages     = {29},
  keywords     = {algebra of programs, applicative computing systems, applicative state transition systems, combining forms, functional forms, functional programming, metacomposition, models of computing systems, program correctness, program termination, program transformation, programming languages, von Neumann computers, von Neumann languages}
}
@book{grace_hopper_and_the_invention_of_the_information_age_2009,
  author       = {Beyer, Kurt W.},
  title        = {Grace Hopper and the Invention of the Information Age},
  year         = {2009},
  isbn         = {026201310X},
  publisher    = {The MIT Press},
  abstract     = {A Hollywood biopic about the life of computer pioneer Grace Murray Hopper (19061992) would go like this: a young professor abandons the ivy-covered walls of academia to serve her country in the Navy after Pearl Harbor and finds herself on the front lines of the computer revolution. She works hard to succeed in the all-male computer industry, is almost brought down by personal problems but survives them, and ends her career as a celebrated elder stateswoman of computing, a heroine to thousands, hailed as the inventor of computer programming. Throughout Hopper's later years, the popular media told this simplified version of her life story. In Grace Hopper and the Invention of the Information Age, Kurt Beyer goes beyond the screenplay-ready myth to reveal a more authentic Hopper, a vibrant and complex woman whose career paralleled the meteoric trajectory of the postwar computer industry. Hopper made herself "one of the boys" in Howard Aiken's wartime Computation Laboratory at Harvard, then moved on to the Eckert and Mauchly Computer Corporation. Both rebellious and collaborative, she was influential in male-dominated military and business organizations at a time when women were encouraged to devote themselves to housework and childbearing. Hopper's greatest technical achievement was to create the tools that would allow humans to communicate with computers in terms other than ones and zeroes. This advance influenced all future programming and software design and laid the foundation for the development of user-friendly personal computers. Lemelson Center Studies in Invention and Innovation series}
}
@article{influence_of_programming_techniques_on_the_design_of_computers,
  author       = {Hopper, G.M. and Mauchly, J.W.},
  journal      = {Proceedings of the IEEE},
  title        = {Influence of programming techniques on the design of computers},
  year         = {1997},
  volume       = {85},
  number       = {3},
  pages        = {470--474},
  keywords     = {Programming profession;Computer aided instruction;Design engineering;Costs;Application software;Hardware;Equations;Economics;High performance computing;Computer applications},
  doi          = {10.1109/5.558722}
}
@inbook{Mahoney+2011+77+85,
  url          = {https://doi.org/10.4159/9780674274983-007},
  title        = {5 Software: The Self-Programming Machine},
  booktitle    = {Histories of Computing},
  author       = {Michael Sean Mahoney},
  publisher    = {Harvard University Press},
  address      = {Cambridge, MA and London, England},
  pages        = {77--85},
  doi          = {doi:10.4159/9780674274983-007},
  isbn         = {9780674274983},
  year         = {2011},
  lastchecked  = {2025-10-05}
}
@misc{computer_history_museum_collections,
  title        = {Collections},
  url          = {https://computerhistory.org/collections/},
  publisher    = {Computer History Museum},
  language     = {en},
  urldate      = {2025-10-05},
  journal      = {CHM}
}
@misc{smithsonian_computer_history_collection,
  title        = {Computer {History} {Collection}},
  url          = {https://americanhistory.si.edu/comphist/},
  urldate      = {2025-10-05},
  publisher    = {Smithsonian National Museum of American History}
}
@book{idea_factory,
  title        = {The Idea Factory: Bell Labs and the Great Age of American Innovation},
  publisher    = {Penguin Press},
  isbn         = {9781594203282},
  author       = {Jon Gertner}
}
@book{phd_thesis_bohm_sestoft_2016,
  title        = {Calculatrices digitales: Du d{\'e}chiffrage de formules logico-math{\'e}matiques par la machine m{\^e}me dans la conception du programme},
  author       = {Corrado B{\"o}hm and Peter Sestoft},
  note         = {Translation into English of Corrado B{\"o}hm's ETH Z{\"u}rich PhD dissertation from the French original published 1954 in Bologna, Italy.},
  year         = {2016},
  month        = may,
  day          = {4},
  language     = {Fransk},
  note         = {Original title: DIGITAL COMPUTERS On encoding logical-mathematical formulas using the machine itself during program conception}
}
@book{history_of_computing_in_the_twentieth_century_1980,
  author       = {Howlett, J. and Rota, Gian Carlo and Metropolis, Nicholas},
  title        = {History of Computing in the Twentieth Century},
  year         = {1980},
  isbn         = {0124916503},
  publisher    = {Academic Press, Inc.},
  address      = {USA}
}
@book{dealers_of_lightning_xerox_parc_hiltzik1999,
  author       = {Hiltzik, Michael A.},
  title        = {Dealers of Lightning: Xerox PARC and the Dawn of the Computer Age},
  publisher    = {HarperBusiness},
  year         = {1999},
  isbn         = {9780887308918},
  address      = {New York}
}
@book{sammet_programming_languages_history_and_fundamentals_1969,
  author       = {Sammet, Jean E.},
  title        = {Programming Languages: History and Fundamentals},
  year         = {1969},
  isbn         = {0137299885},
  publisher    = {Prentice-Hall, Inc.},
  address      = {USA}
}
@article{women_in_computing_history_2002,
  author       = {G\"{u}rer, Denise},
  title        = {Women in computing history},
  year         = {2002},
  issue_date   = {June 2002},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  volume       = {34},
  number       = {2},
  issn         = {0097-8418},
  url          = {https://doi.org/10.1145/543812.543843},
  doi          = {10.1145/543812.543843},
  abstract     = {Exciting inventions, innovative technology, human interaction, and intriguing politics fill computing history. However, the recorded history is mainly composed of male achievements and involvements, even though women have played substantial roles. This situation is not unusual. Most science fields are notorious for excluding, undervaluing, or overlooking the accomplishments of their female scientists [1, 16, 17, 22]. As J.A.N. Lee points out, it is up to the historians and others to remedy this imbalance (see this issue [14]). Some steps have been taken towards this goal through publishing biographies on women in technology [2, 5, 6, 8, 12, 13, 18, 20, 21, 23, 24], also see this issue [7], and through honoring the pioneers with various awards such as the GHC'97 Pioneering Awards (Figure 1), the WITI Hall of Fame, and the AWC Lovelace Award. A few online sites contain biographies of women in technology, shown in Table 1 below. However, even with these resources, many women who have contributed significantly to computer science are still to be discovered.},
  journal      = {SIGCSE Bull.},
  month        = jun,
  pages        = {116--120},
  numpages     = {5}
}
@misc{aho_oral_history_2022,
  author       = {Aho, Alfred V.},
  title        = {Oral History Interview with Alfred V. Aho},
  year         = {2022},
  month        = {June},
  day          = {13},
  howpublished = {Video interview},
  note         = {Interviewer: Hansen Hsu. Computer History Museum Oral History Collection. Catalogue number 102792705. Duration: 3:00:19. MOV format. Gift of Computer History Museum.},
  organization = {Computer History Museum},
  address      = {Chatham, New Jersey, USA},
  language     = {English},
  url          = {https://www.computerhistory.org/collections/catalog/102792704/}
}
@misc{aiken_oral_history_1973,
  author       = {Aiken, Howard},
  title        = {Oral History Interview with Howard Aiken},
  year         = {1973},
  month        = {February},
  day          = {26},
  howpublished = {Transcript},
  note         = {Interview conducted February 26-27, 1973, by Henry Tropp and I.~B. Cohen. Part of the Computer Oral History Collection, 1969-1973, 1977. Repository: Archives Center, National Museum of American History, Smithsonian Institution.},
  organization = {Smithsonian Institution},
  address      = {Washington, D.C., USA},
  url          = {https://mads.si.edu/mads/id/NMAH-AC0196_aike73027},
  language     = {English}
}
@book{aho-ullman-theory-of-parsing-translation-and-compiling-1972,
  author       = {Aho, Alfred V. and Ullman, Jeffrey D.},
  title        = {The theory of parsing, translation, and compiling},
  year         = {1972},
  isbn         = {0139145567},
  publisher    = {Prentice-Hall, Inc.},
  address      = {USA},
  abstract     = {From volume 1 Preface (See Front Matter for full Preface)This book is intended for a one or two semester course in compiling theory at the senior or graduate level. It is a theoretically oriented treatment of a practical subject. Our motivation for making it so is threefold.(1) In an area as rapidly changing as Computer Science, sound pedagogy demands that courses emphasize ideas, rather than implementation details. It is our hope that the algorithms and concepts presented in this book will survive the next generation of computers and programming languages, and that at least some of them will be applicable to fields other than compiler writing.(2) Compiler writing has progressed to the point where many portions of a compiler can be isolated and subjected to design optimization. It is important that appropriate mathematical tools be available to the person attempting this optimization.(3) Some of the most useful and most efficient compiler algorithms, e.g. LR(k) parsing, require a good deal of mathematical background for full understanding. We expect, therefore, that a good theoretical background will become essential for the compiler designer.While we have not omitted difficult theorems that are relevant to compiling, we have tried to make the book as readable as possible. Numerous examples are given, each based on a small grammar, rather than on the large grammars encountered in practice. It is hoped that these examples are sufficient to illustrate the basic ideas, even in cases where the theoretical developments are difficult to follow in isolation.From volume 2 Preface (See Front Matter for full Preface)Compiler design is one of the first major areas of systems programming for which a strong theoretical foundation is becoming available. Volume I of The Theory of Parsing, Translation, and Compiling developed the relevant parts of mathematics and language theory for this foundation and developed the principal methods of fast syntactic analysis. Volume II is a continuation of Volume I, but except for Chapters 7 and 8 it is oriented towards the nonsyntactic aspects of compiler design.The treatment of the material in Volume II is much the same as in Volume I, although proofs have become a little more sketchy. We have tried to make the discussion as readable as possible by providing numerous examples, each illustrating one or two concepts.Since the text emphasizes concepts rather than language or machine details, a programming laboratory should accompany a course based on this book, so that a student can develop some facility in applying the concepts discussed to practical problems. The programming exercises appearing at the ends of sections can be used as recommended projects in such a laboratory. Part of the laboratory course should discuss the code to be generated for such programming language constructs as recursion, parameter passing, subroutine linkages, array references, loops, and so forth.}
}
@online{aho_turing_award_2020,
  author       = {Haigh, Thomas and ACM Staff},
  title        = {Alfred Vaino Aho --- {A.M. Turing Award Laureate 2020}},
  date         = {2020},
  organization = {Association for Computing Machinery},
  url          = {https://amturing.acm.org/award_winners/aho_1046358.cfm},
  note         = {Citation: ``For fundamental algorithms and theory underlying programming language implementation and for synthesizing these results and those of others in their highly influential books, which educated generations of computer scientists.''},
  language     = {English}
}
@book{history_of_modern_computing_2003_ceruzzi,
  author       = {Ceruzzi, Paul E.},
  title        = {A History of Modern Computing},
  year         = {2003},
  isbn         = {0262532034},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  edition      = {2}
}
@book{aosa_vol1,
  title        = {The Architecture of Open Source Applications, Volume I: Twenty-four designers explain how their software works},
  editor       = {Brown, Amy and Wilson, Greg},
  year         = {2011},
  publisher    = {aosabook.org},
  address      = {Online},
  isbn         = {978-1-257-63804-3},
  url          = {https://aosabook.org/en/index.html},
  note         = {Available online at \url{https://aosabook.org/en/}}
}
@phdthesis{Lattner2002-zt,
  abstract     = {Abstract Modern programming languages and software engineering principles are causing increasing problems for compiler systems. Traditional approaches, which use a simple compile-link-execute model, are unable to provide adequate application performance ...},
  added-at     = {2015-07-14T13:30:28.000+0200},
  author       = {Lattner, Chris Arthur},
  biburl       = {https://www.bibsonomy.org/bibtex/2fe6a01795d434156c888668106070fa0/christophv},
  interhash    = {db8e714e9b13e69ce73c214398af5218},
  intrahash    = {fe6a01795d434156c888668106070fa0},
  keywords     = {Expose LLVM},
  publisher    = {llvm.org},
  school       = {University of Illinois at Urbana-Champaign},
  timestamp    = {2016-01-04T14:22:08.000+0100},
  title        = {{LLVM}: An infrastructure for multi-stage optimization},
  year         = {2002}
}
@online{carruth_understanding_compiler_2015,
  author       = {Chandler Carruth},
  title        = {Understanding Compiler Optimization — Opening Keynote, Meeting C++ 2015},
  date         = {2015-12-19},
  organization = {Meeting C++ / YouTube},
  url          = {https://www.youtube.com/watch?v=FnGCDLhaxKU},
  note         = {YouTube video of opening keynote on compiler optimization}
}
@misc{carruth_modernizing_compiler_2023,
  author       = {Chandler Carruth},
  title        = {Modernizing Compiler Design for Carbon Toolchain},
  year         = {2023},
  howpublished = {YouTube video, CppNow 2023 Conference},
  organization = {CppNow},
  note         = {Premiered Aug 17, 2023. Discusses modern compiler architecture and the Carbon language toolchain.},
  url          = {https://www.youtube.com/watch?v=ZI198eFghJk},
  slides       = {https://github.com/boostcon},
  keywords     = {compiler design, C++, Carbon, LLVM}
}
@online{spickett_flang_levels_up_2025,
  author       = {David Spickett},
  title        = {LLVM Fortran Levels Up: Goodbye \texttt{flang-new}, Hello \texttt{flang}!},
  date         = {2025-03-11},
  organization = {LLVM Project Blog},
  url          = {https://blog.llvm.org/posts/2025-03-11-flang-new/},
  keywords     = {Flang, Fortran, MLIR, LLVM},
  note         = {33 minute read. Blog post on the LLVM Project site discussing the renaming of Flang and its development history.}
}
@online{godbolt_happy_birthday_ce_2022,
  author       = {Matt Godbolt},
  title        = {Happy 10th Birthday Compiler Explorer!},
  date         = {2022-06-22},
  organization = {Matt Godbolt's Blog},
  url          = {https://xania.org/202206/happy-birthday-ce},
  note         = {Blog post celebrating the 10th anniversary of Compiler Explorer.},
  keywords     = {Compiler Explorer, blog, history}
}
@online{chipletter_history_of_c_compilers_part1,
  author       = {Babbage},
  title        = {A History of C Compilers — Part 1: Performance, Portability and Freedom},
  date         = {2024-05-05},
  organization = {The Chip Letter (Substack)},
  url          = {https://thechipletter.substack.com/p/a-history-of-c-compilers-part-1-performance},
  note         = {Whistle-stop tour of the evolution of C compilers, emphasizing performance, portability, and freedom.},
  keywords     = {C compilers, history, performance, portability}
}
@article{annals_of_the_computation_laboratory_of_harvard_university_1946,
  author       = {Miller, J. C. P.},
  title        = {The Annals of the Computation Laboratory of Harvard University --- 1. Vol. I. A Manual of Operation for the Automatic Sequence Controlled Calculator. Pp. xvi + 561 + 17 plates. 1946. 2. Vol. II. Tables of the Modified Hankel Functions of Order One-third and of their Derivatives. Pp. xxxvi + 235. 1945. 3. Vol. III. Tables of the Bessel Functions of the First Kind of Orders Zero and One. Pp. xxxviii + [652]. 1947. 4. Vol. IV. Tables of the Bessel Functions of the First Kind of Orders Two and Three. Pp. x + [652]. 1947.},
  journal      = {The Mathematical Gazette},
  year         = {1947},
  volume       = {31},
  number       = {295},
  pages        = {178--181},
  doi          = {10.2307/3610522},
  url          = {https://chimera.roma1.infn.it/SP/COMMON/MarkI_operMan_1946.pdf}
}
@online{backus_oral_history_2006,
  author       = {John W. Backus},
  title        = {John Backus Oral History Transcript},
  date         = {2006-09-05},
  organization = {Computer History Museum},
  location     = {Ashland, Oregon, USA},
  note         = {Interviewed by Grady Booch, videography by Gardner Hendrie. 42 pages. Catalogue number 102657970. Acquisition number X3715.2007.},
  url          = {https://www.computerhistory.org/collections/catalog/102657970/},
  keywords     = {FORTRAN, IBM 704, programming languages, software history, oral history},
  language     = {English}
}
@online{backus_ibm_history,
  author       = {IBM Corporation},
  title        = {John Backus — The father of Fortran changed programming forever},
  date         = {2025-10-09},
  organization = {IBM},
  url          = {https://www.ibm.com/history/john-backus},
  note         = {Biography of John W. Backus, covering his work at IBM, development of FORTRAN, and contributions to programming languages.},
  language     = {English}
}
@techreport{IBM_1954_Speedcoding,
  author       = {{International Business Machines Corporation}},
  title        = {IBM Speedcoding System for the Type 701 Electronic Data Processing Machines},
  year         = {1954},
  note         = {[1953-09-10]},
  institution  = {International Business Machines Corporation},
  address      = {New York, USA},
  type         = {Technical Manual},
  number       = {Form 24-6059-0 (5-54:2M-W)},
  url          = {https://archive.computerhistory.org/resources/access/text/2018/02/102678975-05-01-acc.pdf},
  howpublished = {Archived PDF at Computer History Museum},
  urldate      = {2022-07-04}
}
@incollection{Hamming_Feigenbaum_1971_IBM7094,
  author       = {Richard W. Hamming and Edward A. Feigenbaum},
  title        = {The {IBM} 701--7094 II Sequence: A Family by Evolution},
  booktitle    = {Computer Structures: Readings and Examples},
  editor       = {C. Gordon Bell and Allen Newell},
  year         = {1971},
  publisher    = {McGraw-Hill Book Company},
  address      = {New York, USA},
  series       = {McGraw-Hill Computer Science Series},
  url          = {https://tcm.computerhistory.org/ComputerTimeline/Chap41_ibm7094_CS1.pdf},
  note         = {Reprinted by the Computer History Museum, Section 1 of \emph{Computer Structures: Readings and Examples}}
}
@techreport{IBM_1954_FORTRAN_Specifications,
  title        = {Preliminary Report: Specifications for the IBM Mathematical FORmula TRANslating System (FORTRAN)},
  author       = {{International Business Machines Corporation (IBM)}},
  year         = {1954},
  month        = nov,
  institution  = {International Business Machines Corporation},
  type         = {Technical Report},
  number       = {102679231},
  note         = {Gift of J.A.N. Lee. Fortran Archive, Computer History Museum. Acquisition number X2677.2004},
  url          = {https://archive.computerhistory.org/resources/text/Fortran/102679231.05.01.acc.pdf},
  address      = {New York, USA},
  language     = {English},
  howpublished = {Computer History Museum}
}
@online{McJones_2025_FORTRAN_History,
  author       = {Paul McJones},
  title        = {History of FORTRAN and FORTRAN II},
  year         = {2025},
  month        = jul,
  editor       = {Paul McJones},
  organization = {Computer History Museum, Software Preservation Group},
  url          = {https://mcjones.org/dustydecks},
  note         = {Last modified 2025-07-21. Project to preserve source code, design documents, and other materials concerning the original IBM 704 FORTRAN/FORTRAN II compiler.},
  howpublished = {\url{https://www.softwarepreservation.org/projects/FORTRAN/}},
  email        = {paul@mcjones.org},
  language     = {English}
}
@incollection{Backus_1980_Programming_in_America_in_1950s,
  author       = {John W. Backus},
  title        = {Programming in America in the 1950s: Some Personal Impressions},
  booktitle    = {A History of Computing in the Twentieth Century: A Collection of Essays},
  editor       = {N. Metropolis and J. Howlett and Gian-Carlo Rota},
  publisher    = {Academic Press},
  address      = {New York, USA},
  year         = {1980},
  pages        = {125--135},
  url          = {https://www.softwarepreservation.org/projects/FORTRAN/paper/Backus-ProgrammingInAmerica-1976.pdf},
  note         = {Originally written in 1976. Reprinted in \textit{A History of Computing in the Twentieth Century}.},
  language     = {English}
}
@techreport{Knuth_TrabbPardo_1976_Early_Development,
  author       = {Donald E. Knuth and Luis Trabb Pardo},
  title        = {The Early Development of Programming Languages},
  institution  = {Department of Computer Science, Stanford University},
  year         = {1976},
  month        = jul,
  type         = {Technical Report},
  number       = {ADA032123},
  address      = {Stanford, CA, USA},
  pages        = {112},
  note         = {Commissioned by the \textit{Encyclopedia of Computer Science and Technology}, ed. Jack Belzer, Albert G. Holzman, and Allen Kent. Approved for public release.},
  url          = {https://apps.dtic.mil/sti/citations/ADA032123},
  abstract     = {This paper surveys the evolution of high-level programming languages during the first decade of computer programming activity, including contributions from Zuse, Goldstine and von Neumann, Curry, Mauchly, Rutishauser, Böhm, Glennie, Hopper, Backus, Brooker, and others.},
  keywords     = {programming languages, compilers, high-level languages, FORTRAN, early computing, computer history},
  language     = {English}
}
@inproceedings{Backus_Herrick_1954_Speedcoding,
  author       = {John W. Backus and Harlan Herrick},
  title        = {IBM 701 Speedcoding and Other Automatic Programming Systems},
  booktitle    = {Proceedings of the Symposium on Automatic Programming for Digital Computers},
  organization = {Office of Naval Research, Department of the Navy},
  address      = {Washington, D.C., USA},
  year         = {1954},
  month        = may,
  pages        = {106--113},
  note         = {Navy Mathematical Computing Advisory Panel, 13--14 May 1954. Computer History Museum Lot X2677.2004, Box 3 of 6. Donated by J.A.N. Lee.},
  url          = {https://www.softwarepreservation.org/projects/FORTRAN/paper/Backus%20and%20Herrick%20-%20Speedcoding%20-%20ONR%201954.pdf},
  howpublished = {Archived by the Computer History Museum, curated by Paul McJones (2005-12-30).},
  language     = {English}
}
@misc{Hopper_1980_Oral_History,
  author       = {Grace Murray Hopper},
  title        = {Grace Hopper Oral History},
  year         = {1980},
  month        = dec,
  howpublished = {Transcript, Computer History Museum Oral History Collection},
  editor       = {Angeline Pantages},
  interviewer  = {Angeline Pantages},
  institution  = {Computer History Museum},
  address      = {Naval Data Automation Command, Maryland, USA},
  url          = {https://www.computerhistory.org/collections/catalog/102702026/},
  note         = {Catalogue number 102702026. Gift of Angela Pantages Doyne. Acquisition number X5142.2009.},
  language     = {English},
  abstract     = {In this 1980 interview, Grace Murray Hopper discusses her entry into computing, work with Howard Aiken on the Harvard Mark series, collaboration with John Mauchly and the Eckert-Mauchly Computer Corporation, and the development of the A-0 and Flow-Matic compilers leading to COBOL.},
  keywords     = {Grace Hopper, COBOL, Flow-Matic, FORTRAN, UNIVAC, Mark I, Eckert-Mauchly, early programming languages, oral history}
}
@inbook{howard_aiken_and_the_dawn_of_the_computer_age_2000,
  author       = {Cohen, I. Bernard},
  title        = {Howard Aiken and the dawn of the computer age},
  year         = {2000},
  isbn         = {0262181975},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  booktitle    = {The First Computers: History and Architectures},
  pages        = {107--120},
  numpages     = {14}
}
@book{10.5555/583656,
  author       = {Aspray, William},
  title        = {Proceedings of a Symposium on Large Scale Digital Calculating Machinery 1948},
  year         = {1985},
  isbn         = {0262081520},
  publisher    = {MIT Press},
  address      = {Cambridge, MA, USA},
  abstract     = {From the Publisher:In January 1947, the Navy Department Bureau of Ordnance and Harvard University jointly sponsored a symposium at the Harvard Computation Laboratory on large-scale digital calculating machinery. It provided one of the first and most important early forums for discussion of the problems and approaches in the design, construction, operation, and application of computers. Coming before the establishment of professional journals, societies, or regular meetings in computer science, the proceedings of the symposium offer the best picture of computing technology in the early years that we have available. Included are papers by Howard Aiken, Samuel Caldwell, Jay Forrester, Herman Goldstine, John Mauchly, George Stibitz, and over twenty others.   Proceedings of a Symposium on Large-Scale Digital Calculating Machinery was published in 1948 by Harvard University Press. It is Volume VIII in the Charles Babbage Institute Reprint Series.},
  url          = {http://www.bitsavers.org/pdf/harvard/Proceedings_of_a_Second_Symposium_on_Large-Scale_Digital_Calculating_Machinery_Sep49.pdf}
}
@inproceedings{education_of_a_computer_1952_hopper,
  author       = {Hopper, Grace Murray},
  title        = {The education of a computer},
  year         = {1952},
  isbn         = {9781450373623},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/609784.609818},
  doi          = {10.1145/609784.609818},
  abstract     = {While the materialization is new, the idea of mechanizing mathematical thinking is not new. Its lineage starts with the abacus and descends through Pascal,Leibnitz, and Babbage. More immediately, the ideas here presented originate from Professor Howard H. Aiken of Harvard University, Dr.  John W. Mauchly of Eckert-Mauchly and Dr. M. V. Wilkes of the University of Cambridge. From Professor Aiken came, in 1946, the idea of a library of routines described in the Mark I manual, and the concepts embodied in the Mark III coding machine, from Dr. Mauchly, the basic principles of the "short-order code" and suggestions, criticisms, and untiring patience in listening to these present attempts; from Dr. Wilkes, the greatest help of all, a book on the subject. For those of their ideas which are included herein, I most earnestly express my debt and my appreciation.},
  booktitle    = {Proceedings of the 1952 ACM National Meeting (Pittsburgh)},
  pages        = {243--249},
  numpages     = {7},
  location     = {Pittsburgh, Pennsylvania},
  series       = {ACM '52}
}
@inproceedings{ridgway_compiling_routines_1952,
  author       = {Ridgway, Richard K.},
  title        = {Compiling routines},
  year         = {1952},
  isbn         = {9781450379250},
  publisher    = {Association for Computing Machinery},
  address      = {New York, NY, USA},
  url          = {https://doi.org/10.1145/800259.808980},
  doi          = {10.1145/800259.808980},
  abstract     = {Since the advent of automatic computation, programmers have devoted much of their time and energy to looking up, adjusting, and transcribing material previously programmed. This has proved a most inefficient method of program preparation. Within the experience of the programming staff of Eckert-Mauchly, such manipulation and transcription has been a major source of programming errors.In an attempt to lighten the load on the programmer, and to eliminate such errors, members of the Computational Analysis Laboratory have devised programs called "compilers". A compiler looks up subroutines, adjusts them, and assembles them, as a complete program. The fruitfulness of the compiler method of program preparation is now clearly evident. One immediate result is a considerable saving in time in the preparation of programs for the solution of mathematical problems. At present, compilers are capable of handling scientific problems, and in the near future, they will be available to treat commercial problems.},
  booktitle    = {Proceedings of the 1952 ACM National Meeting (Toronto)},
  pages        = {1-5},
  numpages     = {5},
  location     = {Toronto, Ontario, Canada},
  series       = {ACM '52}
}
@misc{pentagon_hopper_univac_workshop_1953,
  title        = {Second Workshop on {UNIVAC} Automatic Programming (Exhibit F)},
  year         = {1953},
  month        = dec,
  day          = {1},
  location     = {The Pentagon},
  institution  = {Directorate of Management Analysis, Deputy Chief of Staff, Comptroller, Headquarters, U.S. Air Force, and Remington Rand, Inc.},
  howpublished = {Archival material, Box 5, Folder 1, Grace Murray Hopper Collection, Series 6: Compiling Routines},
  url          = {https://americanhistory.si.edu/fr/collections/archival-item/sova-nmah-ac-0324-ref334},
  note         = {Record ID: ebl-1562729477047-1562729477111-2. GUID: https://n2t.net/ark:/65665/ep840713f12-e928-4c4a-a0fe-7010232d7b9b. Usage conditions apply.},
  author       = {{Directorate of Management Analysis, Deputy Chief of Staff, Comptroller, Headquarters, U.S. Air Force, and Remington Rand, Inc.}},
  collection   = {Grace Murray Hopper Collection},
}
@inproceedings{hopper_interlude_1956,
	address = {Washington, {D.C.}},
	title = {The Interlude 1954-1956},
	language = {English},
	booktitle = {Symposium on Advanced Programming Methods for Digital Computers: Washington, {D.C.}, June 28, 29, 1956},
	publisher = {Office of Naval Research, Dept. of the Navy},
	author = {Hopper, Grace M.},
	year = {1956},
	pages = {1--2}
}
@techreport{ash_etal_1957_math-matic_manual,
  title        = {Preliminary Manual for MATH-MATIC and ARITH-MATIC Systems for Algebraic Translation and Compilation for UNIVAC I and II},
  author       = {Ash, R. and Broadwin, E. and Della Valle, V. and Greene, M. and Jenny, A. and Katz, C. and Yu, L.},
  institution  = {Automatic Programming Development, Remington Rand UNIVAC},
  address      = {Philadelphia, Pennsylvania},
  year         = {1957},
  month        = apr,
  day          = {19},
  url          = {https://archive.computerhistory.org/resources/access/text/2016/06/102724614-05-01-acc.pdf},
  note         = {Prepared by the Automatic Programming Development group at Remington Rand UNIVAC.},
  howpublished = {Technical report},
}
@inbook{sammet_early_history_of_cobol_1978,
  author = {Sammet, Jean E.},
  title = {The early history of COBOL},
  year = {1978},
  isbn = {0127450408},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/800025.1198367},
  booktitle = {History of Programming Languages},
  pages = {199-243},
  numpages = {45}
}
@misc{hopper_1955_preliminary_definitions_data_processing_compiler,
  author       = {Hopper, Grace Murray},
  title        = {Preliminary Definitions: Data-Processing Compiler},
  year         = {1955},
  month        = jan,
  day          = {31},
  howpublished = {Archival material, Box 4, Folder 12, Grace Murray Hopper Collection, Series 5: Eckert-Mauchly Corporation},
  institution  = {Smithsonian National Museum of American History},
  note         = {Record ID: ebl-1562729477047-1562729477108-3. GUID: https://n2t.net/ark:/65665/ep8441f23a6-5a7e-40dd-a2c4-d7060145f911. Usage conditions apply.},
  url          = {https://americanhistory.si.edu/collections/archival-item/sova-nmah-ac-0324-ref311},
}
