\makeglossaries

\newglossaryentry{bytecode}{
	name={bytecode},
	description={A compiler intermediate representation for the purpose of interpretation or execution instead of optimization}
}

\newglossaryentry{bootstrap}{
	name={bootstrap},
	description={The process of writing a compiler in the language that it compiles, such that an older version of the compiler can be used to compile a newer version of itself}
}

\newglossaryentry{ub}{
	name={undefined behavior},
	description={Source code constructs that are illegal as per the language's specification. Typically, undefined behavior assumed never to happen in a well-formed program, is used by optimizers when certain compiler flags are enabled (such as \texttt{-fstrict-aliasing})}
}

\newglossaryentry{F77}{
	name={Fortran 77},
	description={The 1977 version of the Fortran programming language's standard}
}

\newglossaryentry{F90}{
	name={Fortran 90},
	description={The 1990 version of the Fortran programming language's standard}
}

\newglossaryentry{foss}{
	name={FOSS},
	description={Free and open-source software. This software is typically distributed under a license that allows users to modify and redistribute it freely, though different licenses imply different permissions. The two primary categories of open-source licenses are \textit{permissive} and \textit{copyleft}}
}

\newglossaryentry{ftn}{
	name={Fortran},
	description={The Fortran programming language, standing for \textit{FORmula TRANslator}. Most renditions of the name of the programming language have only the first letter capitalized (\textit{Fortran}), however early versions were rendered as \textit{FORTRAN}. We attempt to use the proper name for each time period. \textit{Fortran} came to be used after the 1990 edition of the standard, while the 1977 standard and all prior versions were rendered as \textit{FORTRAN}}
}

\newglossaryentry{cfg}{
	name={control-flow graph},
	description={In compiler theory, the control-flow graph is a directed graph representing the possible paths of control flow through a program. Nodes of the graph are usually \gls{basicblock}s}
}

\newglossaryentry{inducvar}{
	name={induction variable},
	description={A variable changes by some constant in each iteration of a loop. In \texttt{for (int i=0; i < n; i++)}, the variable \texttt{i} is an induction variable}
}

\newglossaryentry{constant-folding}{
	name={constant folding},
	description={Optimization that replaces an expression with a constant value if the expression's value can be determined at compile time. For example, the expression \texttt{2 + 3} can be replaced with \texttt{5} by the compiler so it need not be calculated by the final program}
}

\newglossaryentry{licm}{
	name={loop-invariant code motion},
	description={Loop-invariant code motion is an optimization that moves code outside of a loop if it does not depend in any way on the loop's \gls{inducvar}s}
}

\newglossaryentry{tripcount}{
	name={trip count},
	description={The number of times a loop will execute}
}

\newglossaryentry{inline-assembly}{
	name={inline assembly},
	description={A programming language feature that allows a programmer to write assembly code directly within another programming language, reading from and writing to variables in the host programming language}
}

\newglossaryentry{separable-compilation}{
	name={separable compilation},
	description={A programming paradigm where a program is divided into multiple modules that can be compiled independently. For example, C source files can be compiled independently, and then linked together to form an executable.}
}

\newglossaryentry{pgo}{
	name={profile-guided optimization},
	description={Compiler optimizations that take advantage of statistics from the execution of a program to improve the compiler's heuristics. A user might compile and run a very program with special compiler flags such that loop hotness and \gls{tripcount}s are recorded, and then re-compile their program such that the compiler can use those statistics to drive its optimization decisions}
}

\newglossaryentry{basicblock}{
	name={basic block},
	description={In compiler theory, a basic block is typically a sequence of instructions that are executed in order and containing a single entry point and exit point}
}

\newglossaryentry{backedge}{
	name={back-edge},
	description={A back-edge is an edge in the \gls{cfg} that returns execution from the end of a loop body back to the beginning of the loop, or the loop's \gls{header-cfg}}
}

\newglossaryentry{header-cfg}{
	name={header},
	description={A header is the first node in a control-flow graph of a loop. Loops begin execution at the entry node, then to the header node, then through the loop body node(s), and finally they either take the \gls{backedge} back to the start of the loop, or they exit the loop}
}

\newacronym{ir}{IR}{Intermediate representation, usually a file format or data structure used inside a compiler to represent the program being compiled}

% Use
% The \Gls{latex} typesetting markup language is specially suitable
% for documents that include \gls{maths}. \Glspl{formula} are
% rendered properly an easily once one gets used to the commands.
% Given a set of numbers, there are elementary methods to compute
% its \acrlong{gcd}, which is abbreviated \acrshort{gcd}. This
% process is similar to that used for the \acrfull{lcm}.
